import { DatabaseManager } from './DatabaseManager';
import { NotificationService } from './NotificationService';
import { SettingsService } from './SettingsService';
import { ChzzkMonitor } from './ChzzkMonitor';
import { TwitterMonitor } from './TwitterMonitor';
import { CafeMonitor } from './CafeMonitor';
import { LiveStatus, TwitterTweet, CafePost } from '@shared/types';

export class MonitoringService {
  private databaseManager: DatabaseManager;
  private notificationService: NotificationService;
  private settingsService: SettingsService;
  public chzzkMonitor: ChzzkMonitor;
  private twitterMonitor: TwitterMonitor;
  private cafeMonitor: CafeMonitor;
  
  private isRunning: boolean = false;
  private monitoringInterval: NodeJS.Timeout | null = null;
  private lastMonitoringTime: number = 0;
  private sleepDetectionThreshold: number = 120000; // 2Î∂Ñ
  
  // ÎÑ§Ïù¥Î≤Ñ Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Í¥ÄÎ¶¨
  private naverLoginStatus: boolean | null = null;
  private statusCheckInterval: NodeJS.Timeout | null = null;
  private statusCheckInProgress: boolean = false;
  private trayService: any = null;

  constructor(databaseManager: DatabaseManager, notificationService: NotificationService) {
    this.databaseManager = databaseManager;
    this.notificationService = notificationService;
    this.settingsService = new SettingsService(databaseManager);
    
    // Î™®ÎãàÌÑ∞ÎßÅ ÏÑúÎπÑÏä§Îì§ Ï¥àÍ∏∞Ìôî
    this.chzzkMonitor = new ChzzkMonitor(databaseManager, notificationService);
    this.twitterMonitor = new TwitterMonitor(databaseManager, notificationService);
    this.cafeMonitor = new CafeMonitor(databaseManager, notificationService, this.settingsService);
  }

  async start(): Promise<boolean> {
    if (this.isRunning) {
      return true;
    }

    try {
      this.isRunning = true;
      this.lastMonitoringTime = Date.now();
      
      // Î™®ÎãàÌÑ∞ÎßÅ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî (Ï§ëÎ≥µ ÏïåÎ¶º Î∞©ÏßÄÎ•º ÏúÑÌïú Í∏∞Ï§ÄÏÑ† ÏÑ§Ï†ï)
      await this.databaseManager.initializeMonitorStates();
      
      // Ïù¥Ï†Ñ ÏÉÅÌÉú Î≥µÏõê (Ïï± Ïû¨ÏãúÏûë Ïãú)
      await this.restoreMonitoringStates();
      
      // Ïπ¥Ìéò Î™®ÎãàÌÑ∞ Ï¥àÍ∏∞Ìôî
      await this.cafeMonitor.initialize();
      
      // Twitter Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉÅÌÉú ÌôïÏù∏
      await this.twitterMonitor.checkInstanceHealth();
      
      // ÎÑ§Ïù¥Î≤Ñ Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî Î∞è Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
      await this.initializeLoginStatus();
      this.startLoginStatusMonitoring();
      
      // ÏÉà Ïä§Ìä∏Î¶¨Î®∏Îì§Ïùò Í∏∞Ï§ÄÏÑ† ÏÑ§Ï†ï (Î¨¥Ïùå Î™®Îìú)
      await this.establishBaselinesForNewStreamers();
      
      console.log('Monitoring service started with state persistence');
      
      // Ï≤´ Ï≤¥ÌÅ¨Î•º 15Ï¥à ÌõÑÏóê Ïã§Ìñâ (Í∏∞Ï§ÄÏÑ† ÏÑ§Ï†ï ÏôÑÎ£å ÌõÑ)
      setTimeout(async () => {
        await this.performMonitoringCheck();
        this.scheduleNextCheck();
      }, 15000);
      
      return true;
    } catch (error) {
      console.error('Failed to start monitoring:', error);
      this.isRunning = false;
      return false;
    }
  }

  async stop(): Promise<boolean> {
    if (!this.isRunning) {
      return true;
    }

    try {
      this.isRunning = false;
      
      if (this.monitoringInterval) {
        clearTimeout(this.monitoringInterval);
        this.monitoringInterval = null;
      }
      
      // Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ
      this.stopLoginStatusMonitoring();
      
      // Î∏åÎùºÏö∞Ï†Ä Ï†ïÎ¶¨
      await this.cafeMonitor.cleanup();
      this.chzzkMonitor.cleanup();
      this.twitterMonitor.cleanup();
      
      // ÏïåÎ¶º Ìï∏Îì§Îü¨ Ï†ïÎ¶¨
      this.notificationService.cleanupAllHandlers();
      
      console.log('Monitoring service stopped');
      return true;
    } catch (error) {
      console.error('Failed to stop monitoring:', error);
      return false;
    }
  }

  private scheduleNextCheck(): void {
    if (!this.isRunning) return;

    const interval = this.settingsService.getCheckInterval() * 1000;
    
    this.monitoringInterval = setTimeout(async () => {
      await this.performMonitoringCheck();
      this.scheduleNextCheck();
    }, interval);
  }

  private async restoreMonitoringStates(): Promise<void> {
    try {
      console.log('üîÑ Restoring monitoring states from database...');
      
      const streamers = await this.databaseManager.getStreamers();
      let statesRestored = 0;
      
      for (const streamer of streamers) {
        if (!streamer.isActive) continue;
        
        // CHZZK ÏÉÅÌÉú Î≥µÏõê
        if (streamer.chzzkId) {
          const chzzkState = await this.databaseManager.getMonitorState(streamer.id, 'chzzk');
          if (chzzkState?.lastStatus === 'live') {
            // Î©îÎ™®Î¶¨ Ï∫êÏãúÏóê ÎùºÏù¥Î∏å ÏÉÅÌÉú Î≥µÏõê
            this.chzzkMonitor['previousLiveStatus'].set(streamer.id.toString(), true);
            statesRestored++;
          }
        }
        
        // Twitter ÏÉÅÌÉú Î≥µÏõê
        if (streamer.twitterUsername) {
          const twitterState = await this.databaseManager.getMonitorState(streamer.id, 'twitter');
          if (twitterState?.lastContentId) {
            // Î©îÎ™®Î¶¨ Ï∫êÏãúÏóê ÎßàÏßÄÎßâ Ìä∏Ïúó ID Î≥µÏõê
            this.twitterMonitor['lastTweetIds'].set(streamer.twitterUsername, twitterState.lastContentId);
            statesRestored++;
          }
        }
        
        // Cafe ÏÉÅÌÉú Î≥µÏõê
        if (streamer.naverCafeUserId) {
          const cafeState = await this.databaseManager.getMonitorState(streamer.id, 'cafe');
          if (cafeState?.lastContentId) {
            // Î©îÎ™®Î¶¨ Ï∫êÏãúÏóê ÎßàÏßÄÎßâ Í≤åÏãúÎ¨º ID Î≥µÏõê
            this.cafeMonitor['lastPostIds'].set(streamer.naverCafeUserId, cafeState.lastContentId);
            statesRestored++;
          }
        }
      }
      
      console.log(`‚úÖ Restored ${statesRestored} monitoring states for ${streamers.filter(s => s.isActive).length} active streamers`);
    } catch (error) {
      console.error('‚ùå Failed to restore monitoring states:', error);
    }
  }

  private async performMonitoringCheck(): Promise<void> {
    try {
      const currentTime = Date.now();
      
      // Ï†àÏ†ÑÎ™®Îìú Í∞êÏßÄ
      if (currentTime - this.lastMonitoringTime > this.sleepDetectionThreshold) {
        console.log('Sleep mode detected, triggering missed notification recovery');
        await this.recoverMissedNotifications();
      }
      
      this.lastMonitoringTime = currentTime;
      
      console.log('Performing monitoring check...');
      
      // Î™®Îì† ÌîåÎû´Ìèº Î≥ëÎ†¨ Î™®ÎãàÌÑ∞ÎßÅ
      const [liveStatuses, tweets, cafePosts] = await Promise.all([
        this.checkChzzkStreams(),
        this.checkTwitterFeeds(),
        this.checkCafePosts()
      ]);
      
      // ÎùºÏù¥Î∏å ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      await this.updateLiveStatus(liveStatuses);
      
      // Î™®ÎãàÌÑ∞ÎßÅ ÏÉÅÌÉú Í∏∞Î°ù
      await this.updateMonitoringStatus();
      
      console.log(`Monitoring check completed. Live: ${liveStatuses.filter(s => s.isLive).length}, Tweets: ${tweets.length}, Posts: ${cafePosts.length}`);
      
    } catch (error) {
      console.error('Monitoring check failed:', error);
    }
  }

  private async checkChzzkStreams(): Promise<LiveStatus[]> {
    try {
      return await this.chzzkMonitor.checkAllStreamers();
    } catch (error) {
      console.error('CHZZK monitoring failed:', error);
      return [];
    }
  }

  private async checkTwitterFeeds(): Promise<TwitterTweet[]> {
    try {
      return await this.twitterMonitor.checkAllStreamers();
    } catch (error) {
      console.error('Twitter monitoring failed:', error);
      return [];
    }
  }

  private async checkCafePosts(): Promise<CafePost[]> {
    try {
      return await this.cafeMonitor.checkAllStreamers();
    } catch (error) {
      console.error('Cafe monitoring failed:', error);
      return [];
    }
  }

  private async updateLiveStatus(liveStatuses: LiveStatus[]): Promise<void> {
    try {
      // ÎùºÏù¥Î∏å ÏÉÅÌÉúÎ•º ÌååÏùºÎ°úÎèÑ Ï†ÄÏû• (UI Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏Ïö©)
      const fs = require('fs').promises;
      const path = require('path');
      const { app } = require('electron');
      
      const userDataPath = app.getPath('userData');
      const liveStatusFile = path.join(userDataPath, 'live_status.json');
      
      await fs.writeFile(liveStatusFile, JSON.stringify(liveStatuses, null, 2));
    } catch (error) {
      console.error('Failed to update live status file:', error);
    }
  }

  private async updateMonitoringStatus(): Promise<void> {
    try {
      await this.databaseManager.setSetting('lastCheckTime', new Date().toISOString());
    } catch (error) {
      console.error('Failed to update monitoring status:', error);
    }
  }

  async getLiveStatus(): Promise<LiveStatus[]> {
    try {
      const fs = require('fs').promises;
      const path = require('path');
      const { app } = require('electron');
      
      const userDataPath = app.getPath('userData');
      const liveStatusFile = path.join(userDataPath, 'live_status.json');
      
      const data = await fs.readFile(liveStatusFile, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      console.log('No live status file found, returning empty array');
      return [];
    }
  }

  async recoverMissedNotifications(): Promise<number> {
    try {
      console.log('Starting missed notification recovery...');
      
      let recoveredCount = 0;
      const recoveryStartTime = Date.now();
      
      // ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï (5Î∂Ñ)
      const recoveryTimeout = 300000;
      
      const recoveryPromise = Promise.race([
        this.performRecovery(),
        new Promise<number>((_, reject) => 
          setTimeout(() => reject(new Error('Recovery timeout')), recoveryTimeout)
        )
      ]);
      
      recoveredCount = await recoveryPromise;
      
      // Î≥µÍµ¨ ÏôÑÎ£å ÏïåÎ¶º
      if (recoveredCount > 0) {
        const systemNotification = this.notificationService.createSystemNotification(
          'ÎàÑÎùΩ ÏïåÎ¶º Î≥µÍµ¨ ÏôÑÎ£å',
          `${recoveredCount}Í∞úÏùò ÎàÑÎùΩÎêú ÏïåÎ¶ºÏùÑ Î≥µÍµ¨ÌñàÏäµÎãàÎã§.`
        );
        
        await this.notificationService.sendNotification(systemNotification);
      }
      
      // Î≥µÍµ¨ ÏãúÍ∞Ñ Í∏∞Î°ù
      await this.databaseManager.setSetting('lastRecoveryTime', new Date().toISOString());
      
      console.log(`Missed notification recovery completed. Recovered: ${recoveredCount} notifications`);
      
      return recoveredCount;
    } catch (error) {
      console.error('Failed to recover missed notifications:', error);
      
      // Î≥µÍµ¨ Ïã§Ìå® ÏïåÎ¶º
      const errorNotification = this.notificationService.createSystemNotification(
        'ÏïåÎ¶º Î≥µÍµ¨ Ïã§Ìå®',
        'ÎàÑÎùΩÎêú ÏïåÎ¶º Î≥µÍµ¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
      );
      
      await this.notificationService.sendNotification(errorNotification);
      
      return 0;
    }
  }

  private async performRecovery(): Promise<number> {
    let recoveredCount = 0;
    
    try {
      // ÌòÑÏû¨ ÏÉÅÌÉú Ïä§Ï∫î
      const [liveStatuses, tweets, cafePosts] = await Promise.all([
        this.chzzkMonitor.checkAllStreamers(),
        this.twitterMonitor.checkAllStreamers(),
        this.cafeMonitor.checkAllStreamers()
      ]);
      
      // Í∏∞Ï°¥ ÏïåÎ¶ºÍ≥º ÎπÑÍµêÌïòÏó¨ ÎàÑÎùΩÎêú Í≤ÉÎì§ Ï∞æÍ∏∞
      const existingNotifications = await this.databaseManager.getNotifications({ limit: 1000 });
      const existingKeys = new Set(existingNotifications.map(n => n.uniqueKey));
      
      // ÎùºÏù¥Î∏å ÏïåÎ¶º Î≥µÍµ¨
      for (const status of liveStatuses) {
        if (status.isLive) {
          const uniqueKey = `live_${status.streamerName}_${Date.now()}`;
          if (!existingKeys.has(uniqueKey)) {
            // Î≥µÍµ¨ ÌïÑÏöîÌïú ÎùºÏù¥Î∏å ÏïåÎ¶ºÏù¥ ÏûàÏùÑ Ïàò ÏûàÏßÄÎßå, ÌòÑÏû¨ ÎùºÏù¥Î∏å ÏÉÅÌÉúÎßåÏúºÎ°úÎäî ÌåêÎã® Ïñ¥Î†§ÏõÄ
            // Ïã§Ï†úÎ°úÎäî Îçî Ï†ïÍµêÌïú Î°úÏßÅ ÌïÑÏöî
          }
        }
      }
      
      // Ìä∏ÏúÑÌÑ∞/Ïπ¥Ìéò Î≥µÍµ¨Îäî ÏÉàÎ°ú Î∞úÍ≤¨Îêú Ìï≠Î™©Îì§Ïù¥ Ïù¥ÎØ∏ Ï≤òÎ¶¨Îê®
      recoveredCount += tweets.length + cafePosts.length;
      
      return recoveredCount;
    } catch (error) {
      console.error('Recovery scan failed:', error);
      return 0;
    }
  }

  async initiateNaverLogin(): Promise<boolean> {
    try {
      console.log('üîê Starting Naver login process...');
      const result = await this.cafeMonitor.initiateLogin();
      
      if (result) {
        console.log('‚úÖ Naver login successful');
        // Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ Ïãú ÏÉÅÌÉú Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
        const needLogin = false; // Î°úÍ∑∏Ïù∏ ÏôÑÎ£å -> Î°úÍ∑∏Ïù∏ Î∂àÌïÑÏöî
        this.naverLoginStatus = needLogin;
        this.notifyLoginStatusChange(needLogin);
      } else {
        console.log('‚ùå Naver login failed');
      }
      
      return result;
    } catch (error) {
      console.error('Failed to initiate Naver login:', error);
      return false;
    }
  }

  async initiateNaverLogout(): Promise<boolean> {
    try {
      console.log('üö™ Starting Naver logout process...');
      const result = await this.cafeMonitor.initiateLogout();
      
      if (result) {
        console.log('‚úÖ Naver logout successful');
        // Î°úÍ∑∏ÏïÑÏõÉ ÏÑ±Í≥µ Ïãú ÏÉÅÌÉú Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
        const needLogin = true; // Î°úÍ∑∏ÏïÑÏõÉ ÏôÑÎ£å -> Î°úÍ∑∏Ïù∏ ÌïÑÏöî
        this.naverLoginStatus = needLogin;
        this.notifyLoginStatusChange(needLogin);
      } else {
        console.log('‚ùå Naver logout failed');
      }
      
      return result;
    } catch (error) {
      console.error('Failed to initiate Naver logout:', error);
      return false;
    }
  }

  isMonitoring(): boolean {
    return this.isRunning;
  }


  // Ïπ¥Ìéò Î™®ÎãàÌÑ∞ÎßÅ Î©îÎ™®Î¶¨ Ï∫êÏãú Ï¥àÍ∏∞Ìôî
  clearCafeMemoryCache(): void {
    this.cafeMonitor.clearMemoryCache();
  }

  // Ïä§Ìä∏Î¶¨Î®∏ ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏
  async updateStreamerProfiles(): Promise<void> {
    try {
      const streamers = await this.databaseManager.getStreamers();
      
      for (const streamer of streamers) {
        if (streamer.chzzkId) {
          await this.chzzkMonitor.updateStreamerProfile(streamer);
          await new Promise(resolve => setTimeout(resolve, 1000)); // 1Ï¥à ÎîúÎ†àÏù¥
        }
      }
    } catch (error) {
      console.error('Failed to update streamer profiles:', error);
    }
  }

  // Î™®ÎãàÌÑ∞ÎßÅ ÌÜµÍ≥Ñ
  async getMonitoringStats(): Promise<{
    totalStreamers: number;
    activeStreamers: number;
    liveStreamers: number;
    lastCheckTime?: string;
    isMonitoring: boolean;
  }> {
    try {
      const streamers = await this.databaseManager.getStreamers();
      const liveStatuses = await this.getLiveStatus();
      const lastCheckTime = await this.databaseManager.getSetting('lastCheckTime');
      
      return {
        totalStreamers: streamers.length,
        activeStreamers: streamers.filter(s => s.isActive).length,
        liveStreamers: liveStatuses.filter(s => s.isLive).length,
        lastCheckTime: lastCheckTime || undefined,
        isMonitoring: this.isRunning
      };
    } catch (error) {
      console.error('Failed to get monitoring stats:', error);
      return {
        totalStreamers: 0,
        activeStreamers: 0,
        liveStreamers: 0,
        isMonitoring: this.isRunning
      };
    }
  }

  // ÎÑ§Ïù¥Î≤Ñ Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Í¥ÄÎ¶¨ Î©îÏÑúÎìúÎì§
  private async initializeLoginStatus(): Promise<void> {
    try {
      console.log('üîÑ Initializing Naver login status...');
      const isLoggedIn = await this.cafeMonitor.checkLoginStatus();
      const needLogin = !isLoggedIn;
      this.naverLoginStatus = needLogin;
      
      console.log(`‚úÖ Initial login status: isLoggedIn=${isLoggedIn}, needLogin=${needLogin}`);
      
      // Ï¥àÍ∏∞ ÏÉÅÌÉúÎ•º Î™®Îì† Ïª¥Ìè¨ÎÑåÌä∏Ïóê ÏïåÎ¶º
      this.notifyLoginStatusChange(needLogin);
    } catch (error) {
      console.error('Failed to initialize login status:', error);
      this.naverLoginStatus = true; // Ïò§Î•ò Ïãú Î°úÍ∑∏Ïù∏ ÌïÑÏöîÎ°ú Í∞ÄÏ†ï
      this.notifyLoginStatusChange(true);
    }
  }

  private startLoginStatusMonitoring(): void {
    // 30Ï¥àÎßàÎã§ Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú ÌôïÏù∏
    this.statusCheckInterval = setInterval(async () => {
      if (this.statusCheckInProgress) {
        return; // Ïù¥ÎØ∏ ÌôïÏù∏ Ï§ëÏù¥Î©¥ Ïä§ÌÇµ
      }

      try {
        this.statusCheckInProgress = true;
        const isLoggedIn = await this.cafeMonitor.checkLoginStatus();
        const needLogin = !isLoggedIn;
        
        if (needLogin !== this.naverLoginStatus) {
          console.log(`üîÑ Login status changed: needLogin=${this.naverLoginStatus} ‚Üí ${needLogin} (isLoggedIn=${isLoggedIn})`);
          this.naverLoginStatus = needLogin;
          this.notifyLoginStatusChange(needLogin);
        }
      } catch (error) {
        console.error('Failed to check login status:', error);
      } finally {
        this.statusCheckInProgress = false;
      }
    }, 30000);
    
    console.log('üîÑ Login status monitoring started (30s interval)');
  }

  private stopLoginStatusMonitoring(): void {
    if (this.statusCheckInterval) {
      clearInterval(this.statusCheckInterval);
      this.statusCheckInterval = null;
      console.log('üõë Login status monitoring stopped');
    }
  }

  private notifyLoginStatusChange(needLogin: boolean): void {
    try {
      console.log(`üì¢ Broadcasting login status: needLogin=${needLogin}`);
      
      // Ïõπ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Ïóê ÏÉÅÌÉú Î≥ÄÍ≤Ω ÏïåÎ¶º
      const { webContents } = require('electron');
      const allWebContents = webContents.getAllWebContents();
      allWebContents.forEach((wc: any) => {
        if (!wc.isDestroyed()) {
          wc.send('naver-login-status-changed', { needLogin });
        }
      });
      
      // Ìä∏Î†àÏù¥ Î©îÎâ¥ ÏßÅÏ†ë ÏóÖÎç∞Ïù¥Ìä∏ (Îçî ÌôïÏã§Ìïú Î∞©Î≤ï)
      this.updateTrayMenuDirectly(needLogin);
      
    } catch (error) {
      console.error('Failed to notify login status change:', error);
    }
  }

  setTrayService(trayService: any): void {
    this.trayService = trayService;
  }

  private async updateTrayMenuDirectly(needLogin: boolean): Promise<void> {
    try {
      console.log(`üîÑ Directly updating tray menu: needLogin=${needLogin}`);
      
      if (this.trayService) {
        // TrayServiceÎ•º ÌÜµÌïú ÏßÅÏ†ë ÏóÖÎç∞Ïù¥Ìä∏
        const stats = await this.getMonitoringStats();
        this.trayService.updateContextMenu({
          ...stats,
          needNaverLogin: needLogin
        });
        console.log('‚úÖ Tray menu updated via TrayService');
      } else {
        // Î∞±ÏóÖ: Ï†ÑÏó≠ Ï∞∏Ï°∞Î•º ÌÜµÌïú ÏóÖÎç∞Ïù¥Ìä∏
        const { app } = require('electron');
        if (app.streamerAlarmApp && app.streamerAlarmApp.updateTrayMenuWithLoginStatus) {
          app.streamerAlarmApp.updateTrayMenuWithLoginStatus(needLogin);
          console.log('‚úÖ Tray menu updated via global reference');
        }
      }
    } catch (error) {
      console.error('Failed to update tray menu directly:', error);
    }
  }

  // Ïô∏Î∂ÄÏóêÏÑú Ìò∏Ï∂úÌï† Ïàò ÏûàÎäî ÎèôÍ∏∞ÌôîÎêú Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú ÌôïÏù∏
  async checkNaverLoginStatus(): Promise<boolean> {
    try {
      // Ïã§Ï†ú Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú ÌôïÏù∏ (Ï∫êÏãú ÏóÜÏù¥ Ìï≠ÏÉÅ ÏµúÏã† ÏÉÅÌÉú ÌôïÏù∏)
      const isLoggedIn = await this.cafeMonitor.checkLoginStatus();
      
      // ÏÉÅÌÉú Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
      this.naverLoginStatus = !isLoggedIn; // needLogin = !isLoggedIn
      
      console.log(`üîç Final login status: isLoggedIn=${isLoggedIn}, needLogin=${!isLoggedIn}`);
      
      // UIÏóêÏÑú ÏÇ¨Ïö©ÌïòÎäî needLogin Î∞òÌôò (true = Î°úÍ∑∏Ïù∏ ÌïÑÏöî, false = Î°úÍ∑∏Ïù∏ Î∂àÌïÑÏöî)
      return !isLoggedIn;
    } catch (error) {
      console.error('Failed to check Naver login status:', error);
      return true; // Ïã§Ìå® Ïãú Î°úÍ∑∏Ïù∏ ÌïÑÏöîÌïú Í≤ÉÏúºÎ°ú Ï≤òÎ¶¨
    }
  }

  // ÏÉà Ïä§Ìä∏Î¶¨Î®∏Îì§ÏùÑ ÏúÑÌïú Í∏∞Ï§ÄÏÑ† ÏÑ§Ï†ï (Î¨¥Ïùå Î™®Îìú - ÏïåÎ¶º ÏóÜÏù¥ ÌòÑÏû¨ ÏÉÅÌÉú Ï†ÄÏû•)
  private async establishBaselinesForNewStreamers(): Promise<void> {
    try {
      console.log('üîÑ Establishing baselines for new streamers (silent mode)...');
      
      const streamersNeedingBaseline = await this.databaseManager.getStreamersNeedingBaseline();
      
      if (streamersNeedingBaseline.length === 0) {
        console.log('‚úÖ No streamers need baseline establishment');
        return;
      }
      
      console.log(`üìä Found ${streamersNeedingBaseline.length} streamer-platform combinations needing baseline`);
      
      // Group by platform for batch processing
      const platformGroups = streamersNeedingBaseline.reduce((groups, item) => {
        if (!groups[item.platform]) groups[item.platform] = [];
        groups[item.platform].push(item);
        return groups;
      }, {} as Record<string, typeof streamersNeedingBaseline>);
      
      let baselineCount = 0;
      
      // Process each platform
      for (const [platform, streamers] of Object.entries(platformGroups)) {
        console.log(`üéØ Establishing baseline for ${streamers.length} streamers on ${platform}...`);
        
        for (const { streamerId, streamerName } of streamers) {
          try {
            await this.establishBaselineForPlatform(streamerId, streamerName, platform);
            baselineCount++;
            
            // Brief delay between streamers to avoid overwhelming APIs
            await this.delay(500);
          } catch (error) {
            console.error(`‚ùå Failed to establish baseline for ${streamerName} on ${platform}:`, error);
          }
        }
      }
      
      console.log(`‚úÖ Baseline establishment completed: ${baselineCount}/${streamersNeedingBaseline.length} successful`);
    } catch (error) {
      console.error('‚ùå Failed to establish baselines for new streamers:', error);
    }
  }

  private async establishBaselineForPlatform(streamerId: number, streamerName: string, platform: string): Promise<void> {
    try {
      switch (platform) {
        case 'chzzk':
          await this.establishChzzkBaseline(streamerId, streamerName);
          break;
        case 'twitter':
          await this.establishTwitterBaseline(streamerId, streamerName);
          break;
        case 'cafe':
          await this.establishCafeBaseline(streamerId, streamerName);
          break;
        default:
          console.warn(`Unknown platform: ${platform}`);
      }
    } catch (error) {
      console.error(`Failed to establish ${platform} baseline for ${streamerName}:`, error);
    }
  }

  private async establishChzzkBaseline(streamerId: number, streamerName: string): Promise<void> {
    try {
      const streamers = await this.databaseManager.getStreamers();
      const streamer = streamers.find(s => s.id === streamerId);
      
      if (!streamer?.chzzkId) {
        console.log(`${streamerName}: No CHZZK ID, skipping baseline`);
        return;
      }
      
      // Get current live status silently (without notifications) - only for this specific streamer
      const currentStatus = await this.chzzkMonitor.checkSingleStreamerLive(streamer);
      
      if (currentStatus) {
        const baselineValue = currentStatus.isLive ? currentStatus.url || 'live' : 'offline';
        await this.databaseManager.establishBaselineForStreamer(streamerId, 'chzzk', baselineValue);
        console.log(`üì∫ ${streamerName}: CHZZK baseline set (${currentStatus.isLive ? 'LIVE' : 'OFFLINE'})`);
      }
    } catch (error) {
      console.error(`CHZZK baseline failed for ${streamerName}:`, error);
    }
  }

  private async establishTwitterBaseline(streamerId: number, streamerName: string): Promise<void> {
    try {
      const streamers = await this.databaseManager.getStreamers();
      const streamer = streamers.find(s => s.id === streamerId);
      
      if (!streamer?.twitterUsername) {
        console.log(`${streamerName}: No Twitter username, skipping baseline`);
        return;
      }
      
      // Get latest tweet silently (without notifications) - only for this specific streamer
      const tweets = await this.twitterMonitor.checkSingleStreamerTweets(streamer);
      
      if (tweets.length > 0) {
        // Use the latest tweet ID as baseline
        const latestTweet = tweets[tweets.length - 1];
        await this.databaseManager.establishBaselineForStreamer(streamerId, 'twitter', latestTweet.id);
        console.log(`üê¶ ${streamerName}: Twitter baseline set (latest: ${latestTweet.id})`);
      }
    } catch (error) {
      console.error(`Twitter baseline failed for ${streamerName}:`, error);
    }
  }

  private async establishCafeBaseline(streamerId: number, streamerName: string): Promise<void> {
    try {
      const streamers = await this.databaseManager.getStreamers();
      const streamer = streamers.find(s => s.id === streamerId);
      
      if (!streamer?.naverCafeUserId) {
        console.log(`${streamerName}: No Cafe user ID, skipping baseline`);
        return;
      }
      
      // Check if logged in to Cafe
      if (!await this.cafeMonitor.ensureLoggedIn()) {
        console.log(`${streamerName}: Not logged into Cafe, skipping baseline`);
        return;
      }
      
      // Get latest cafe posts silently (without notifications) - only for this specific streamer
      const posts = await this.cafeMonitor.checkSingleStreamerPosts(streamer);
      
      if (posts.length > 0) {
        // Use the latest post ID as baseline
        const latestPost = posts[posts.length - 1];
        await this.databaseManager.establishBaselineForStreamer(streamerId, 'cafe', latestPost.id);
        console.log(`üí¨ ${streamerName}: Cafe baseline set (latest: ${latestPost.id})`);
      }
    } catch (error) {
      console.error(`Cafe baseline failed for ${streamerName}:`, error);
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}