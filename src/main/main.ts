import { app, BrowserWindow, Tray, Menu, ipcMain, shell, dialog } from 'electron';
import * as path from 'path';
import { DatabaseManager } from './services/DatabaseManager';
import { MonitoringService } from './services/MonitoringService';
import { NotificationService } from './services/NotificationService';
import { TrayService } from './services/TrayService';
import { SettingsService } from './services/SettingsService';
import { IpcEvents } from '@shared/types';

class StreamerAlarmApp {
  private mainWindow: BrowserWindow | null = null;
  private tray: Tray | null = null;
  private databaseManager: DatabaseManager;
  private monitoringService: MonitoringService;
  private notificationService: NotificationService;
  private trayService: TrayService;
  private settingsService: SettingsService;
  private isDev: boolean;

  constructor() {
    this.isDev = process.env.NODE_ENV === 'development';
    
    // ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî
    this.databaseManager = new DatabaseManager();
    this.settingsService = new SettingsService(this.databaseManager);
    this.notificationService = new NotificationService(this.databaseManager);
    this.monitoringService = new MonitoringService(
      this.databaseManager,
      this.notificationService
    );
    this.trayService = new TrayService(this);
  }

  async initialize(): Promise<void> {
    console.log('Starting app initialization...');
    
    // Ïï± Ï§ÄÎπÑ ÎåÄÍ∏∞
    await app.whenReady();
    console.log('Electron app ready');

    // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî
    try {
      await this.databaseManager.initialize();
      console.log('Database initialized successfully');
    } catch (error) {
      console.error('Database initialization failed:', error);
      // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïã§Ìå® ÏãúÏóêÎèÑ Ïï± Í≥ÑÏÜç Ïã§Ìñâ
    }

    // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò (ÌïÑÏöîÌïú Í≤ΩÏö∞)
    await this.migrateExistingData();

    // Î©îÏù∏ ÏúàÎèÑÏö∞ ÏÉùÏÑ±
    try {
      this.createMainWindow();
      console.log('Main window created successfully');
      
      // ÏÑ§Ï†ï ÏÑúÎπÑÏä§Ïóê Î©îÏù∏ ÏúàÎèÑÏö∞ Ï†ÑÎã¨
      if (this.mainWindow) {
        this.settingsService.setMainWindow(this.mainWindow);
      }
      
      // ÏÑ§Ï†ï ÏÑúÎπÑÏä§Ïóê Ìä∏Î†àÏù¥ ÏÑúÎπÑÏä§ Ï†ÑÎã¨
      this.settingsService.setTrayService(this.trayService);
    } catch (error) {
      console.error('Main window creation failed:', error);
      throw error; // Î©îÏù∏ Ï∞Ω ÏÉùÏÑ± Ïã§Ìå®Îäî ÏπòÎ™ÖÏ†ÅÏù¥ÎØÄÎ°ú Ïï± Ï¢ÖÎ£å
    }

    // ÏãúÏä§ÌÖú Ìä∏Î†àÏù¥ ÏÑ§Ï†ï
    try {
      this.setupTray();
      // TrayServiceÏóê MonitoringService Ï†ÑÎã¨
      this.trayService.setMonitoringService(this.monitoringService);
      
      // MonitoringServiceÏóê TrayService Ï†ÑÎã¨ (ÏñëÎ∞©Ìñ• Ï∞∏Ï°∞)
      this.monitoringService.setTrayService(this.trayService);
      
      // Ï¥àÍ∏∞Ìôî ÏôÑÎ£å ÌõÑ Ìä∏Î†àÏù¥ Î©îÎâ¥ ÏÉÅÌÉú ÎèôÍ∏∞Ìôî
      setTimeout(async () => {
        try {
          const needNaverLogin = await this.monitoringService.checkNaverLoginStatus();
          const stats = await this.monitoringService.getMonitoringStats();
          this.trayService.updateContextMenu({
            ...stats,
            needNaverLogin: needNaverLogin
          });
          console.log('üîÑ Initial tray menu sync completed');
        } catch (error) {
          console.error('Failed to sync initial tray menu:', error);
        }
      }, 5000); // 5Ï¥à ÌõÑ ÎèôÍ∏∞Ìôî (Ï¥àÍ∏∞Ìôî ÏôÑÎ£å ÌõÑ)
      
      console.log('Tray setup successfully');
    } catch (error) {
      console.error('Tray setup failed:', error);
      // Ìä∏Î†àÏù¥ Ïã§Ìå® ÏãúÏóêÎèÑ Ïï± Í≥ÑÏÜç Ïã§Ìñâ
    }

    // IPC Ìï∏Îì§Îü¨ ÏÑ§Ï†ï
    this.setupIpcHandlers();

    // Î™®ÎãàÌÑ∞ÎßÅ ÏÑúÎπÑÏä§ ÏãúÏûë
    try {
      await this.monitoringService.start();
      console.log('Monitoring service started successfully');
    } catch (error) {
      console.error('Monitoring service failed to start:', error);
      // Î™®ÎãàÌÑ∞ÎßÅ Ïã§Ìå® ÏãúÏóêÎèÑ Ïï± Í≥ÑÏÜç Ïã§Ìñâ
    }

    // ÏûêÎèô ÏãúÏûë ÏÑ§Ï†ï ÌôïÏù∏
    await this.checkAutoStart();
  }

  private createMainWindow(): void {
    console.log('Creating main window...');
    this.mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      minWidth: 800,
      minHeight: 600,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, 'preload.js'),
      },
      icon: path.join(__dirname, '../../assets/icon.png'),
      title: 'Streamer Alarm System',
      show: true, // ÏãúÏûë Ïãú ÌëúÏãú
    });

    // Í∞úÎ∞ú/ÌîÑÎ°úÎçïÏÖò ÌôòÍ≤ΩÏóê Îî∞Î•∏ URL Î°úÎìú
    if (this.isDev) {
      this.mainWindow.loadURL('http://localhost:3000');
      this.mainWindow.webContents.openDevTools();
    } else {
      this.mainWindow.loadFile(path.join(__dirname, 'index.html'));
    }

    // ÏúàÎèÑÏö∞ Ïù¥Î≤§Ìä∏ Ìï∏Îì§ÎßÅ
    this.mainWindow.on('ready-to-show', () => {
      if (this.mainWindow) {
        // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Ï∞ΩÏùÑ ÌëúÏãú (Ïà®ÍπÄ ÌîåÎûòÍ∑∏Í∞Ä ÏóÜÎäî Ìïú)
        if (!this.shouldStartMinimized()) {
          this.mainWindow.show();
          this.mainWindow.focus();
        }
      }
    });

    this.mainWindow.on('close', (event) => {
      if (this.shouldMinimizeToTray()) {
        event.preventDefault();
        this.mainWindow?.hide();
      }
    });

    this.mainWindow.on('closed', () => {
      this.mainWindow = null;
    });
  }

  private setupTray(): void {
    this.tray = this.trayService.createTray();
  }

  private setupIpcHandlers(): void {
    // Ïä§Ìä∏Î¶¨Î®∏ Í¥ÄÎ†® IPC
    ipcMain.handle('get-streamers', async () => {
      console.log('üéØ IPC: get-streamers received');
      try {
        const result = await this.databaseManager.getStreamers();
        console.log('‚úÖ IPC: get-streamers success, count:', result.length);
        return result;
      } catch (error) {
        console.error('‚ùå IPC: get-streamers failed:', error);
        throw error;
      }
    });

    ipcMain.handle('add-streamer', async (_, streamerData) => {
      console.log('üéØ IPC: add-streamer received:', streamerData);
      try {
        // Ïä§Ìä∏Î¶¨Î®∏ Ï∂îÍ∞Ä
        const result = await this.databaseManager.addStreamer(streamerData);
        console.log('‚úÖ IPC: add-streamer success:', result);
        
        // CHZZK IDÍ∞Ä ÏûàÏúºÎ©¥ ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ ÏûêÎèô Í∞ÄÏ†∏Ïò§Í∏∞
        if (result.chzzkId) {
          console.log('üñºÔ∏è Fetching profile image for:', result.name);
          try {
            const profileImageUrl = await this.monitoringService.chzzkMonitor.getProfileImage(result.chzzkId);
            if (profileImageUrl && profileImageUrl !== result.profileImageUrl) {
              const updatedStreamer = { ...result, profileImageUrl };
              await this.databaseManager.updateStreamer(updatedStreamer);
              console.log('‚úÖ Profile image updated for:', result.name);
              return updatedStreamer;
            }
          } catch (profileError) {
            console.warn('‚ö†Ô∏è Failed to fetch profile image:', profileError);
            // ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ Ïã§Ìå®Ìï¥ÎèÑ Ïä§Ìä∏Î¶¨Î®∏ Ï∂îÍ∞ÄÎäî ÏÑ±Í≥µ
          }
        }
        
        return result;
      } catch (error) {
        console.error('‚ùå IPC: add-streamer failed:', error);
        throw error;
      }
    });

    ipcMain.handle('update-streamer', async (_, streamerData) => {
      console.log('üéØ IPC: update-streamer received:', streamerData.name);
      try {
        // Ïä§Ìä∏Î¶¨Î®∏ ÏóÖÎç∞Ïù¥Ìä∏
        const result = await this.databaseManager.updateStreamer(streamerData);
        console.log('‚úÖ IPC: update-streamer success:', result.name);
        
        // CHZZK IDÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÍ±∞ÎÇò ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÏúºÎ©¥ ÏÉàÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞
        if (result.chzzkId && (!result.profileImageUrl || result.chzzkId !== streamerData.chzzkId)) {
          console.log('üñºÔ∏è Updating profile image for:', result.name);
          try {
            const profileImageUrl = await this.monitoringService.chzzkMonitor.getProfileImage(result.chzzkId);
            if (profileImageUrl && profileImageUrl !== result.profileImageUrl) {
              const updatedStreamer = { ...result, profileImageUrl };
              await this.databaseManager.updateStreamer(updatedStreamer);
              console.log('‚úÖ Profile image updated for:', result.name);
              return updatedStreamer;
            }
          } catch (profileError) {
            console.warn('‚ö†Ô∏è Failed to update profile image:', profileError);
            // ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ Ïã§Ìå®Ìï¥ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏Îäî ÏÑ±Í≥µ
          }
        }
        
        return result;
      } catch (error) {
        console.error('‚ùå IPC: update-streamer failed:', error);
        throw error;
      }
    });

    ipcMain.handle('delete-streamer', async (_, streamerId: number) => {
      return await this.databaseManager.deleteStreamer(streamerId);
    });

    // ÏïåÎ¶º Í¥ÄÎ†® IPC
    ipcMain.handle('get-notifications', async (_, options) => {
      return await this.databaseManager.getNotifications(options);
    });

    ipcMain.handle('delete-all-notifications', async () => {
      await this.databaseManager.deleteAllNotifications();
      
      // UI ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏúÑÌï¥ Î©îÏù∏ ÏúàÎèÑÏö∞Ïóê Îπà ÏïåÎ¶º Î™©Î°ù Ï†ÑÏÜ°
      const mainWindow = BrowserWindow.getAllWindows().find(win => !win.isDestroyed());
      if (mainWindow) {
        mainWindow.webContents.send('notification-history-updated', []);
      }
      
      return true;
    });

    ipcMain.handle('mark-notification-read', async (_, notificationId: number) => {
      await this.databaseManager.markNotificationAsRead(notificationId);
      
      // UI ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏúÑÌï¥ Î©îÏù∏ ÏúàÎèÑÏö∞Ïóê ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏïåÎ¶º Î™©Î°ù Ï†ÑÏÜ°
      const mainWindow = BrowserWindow.getAllWindows().find(win => !win.isDestroyed());
      if (mainWindow) {
        const notifications = await this.databaseManager.getNotifications({ limit: 100 });
        mainWindow.webContents.send('notification-history-updated', notifications);
      }
      
      return true;
    });

    ipcMain.handle('mark-all-notifications-read', async () => {
      await this.databaseManager.markAllNotificationsAsRead();
      
      // UI ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏúÑÌï¥ Î©îÏù∏ ÏúàÎèÑÏö∞Ïóê ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏïåÎ¶º Î™©Î°ù Ï†ÑÏÜ°
      const mainWindow = BrowserWindow.getAllWindows().find(win => !win.isDestroyed());
      if (mainWindow) {
        const notifications = await this.databaseManager.getNotifications({ limit: 100 });
        mainWindow.webContents.send('notification-history-updated', notifications);
      }
      
      return true;
    });

    ipcMain.handle('get-unread-count', async () => {
      return await this.databaseManager.getUnreadNotificationCount();
    });

    ipcMain.handle('test-notification', async () => {
      return await this.notificationService.sendTestNotification();
    });

    ipcMain.handle('recover-missed-notifications', async () => {
      return await this.monitoringService.recoverMissedNotifications();
    });

    // ÏÑ§Ï†ï Í¥ÄÎ†® IPC
    ipcMain.handle('get-settings', async () => {
      return await this.settingsService.getAllSettings();
    });

    ipcMain.handle('update-setting', async (_, { key, value }) => {
      return await this.settingsService.updateSetting(key, value);
    });

    // Î™®ÎãàÌÑ∞ÎßÅ Í¥ÄÎ†® IPC
    ipcMain.handle('start-monitoring', async () => {
      return await this.monitoringService.start();
    });

    ipcMain.handle('stop-monitoring', async () => {
      return await this.monitoringService.stop();
    });

    ipcMain.handle('get-live-status', async () => {
      return await this.monitoringService.getLiveStatus();
    });

    ipcMain.handle('get-monitoring-status', async () => {
      return this.monitoringService.isMonitoring();
    });

    // ÎÑ§Ïù¥Î≤Ñ Î°úÍ∑∏Ïù∏/Î°úÍ∑∏ÏïÑÏõÉ IPC
    ipcMain.handle('naver-login', async () => {
      return await this.monitoringService.initiateNaverLogin();
    });

    ipcMain.handle('naver-logout', async () => {
      return await this.monitoringService.initiateNaverLogout();
    });

    // Ïú†Ìã∏Î¶¨Ìã∞ IPC
    ipcMain.handle('open-external', async (_, url: string) => {
      return await shell.openExternal(url);
    });

    ipcMain.handle('show-tray-menu', async () => {
      this.trayService.showContextMenu();
    });

    ipcMain.handle('quit-app', async () => {
      this.quit();
    });

    // Ïπ¥Ìéò Î™®ÎãàÌÑ∞ÎßÅ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî IPC
    ipcMain.handle('clear-cafe-states', async () => {
      try {
        await this.databaseManager.clearCafeMonitorStates();
        // Î©îÎ™®Î¶¨ Ï∫êÏãúÎèÑ Ìï®Íªò Ï¥àÍ∏∞Ìôî
        this.monitoringService.clearCafeMemoryCache();
        return { success: true, message: 'Ïπ¥Ìéò Î™®ÎãàÌÑ∞ÎßÅ ÏÉÅÌÉúÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.' };
      } catch (error) {
        console.error('Failed to clear cafe monitor states:', error);
        return { success: false, message: 'Ïπ¥Ìéò Î™®ÎãàÌÑ∞ÎßÅ ÏÉÅÌÉú Ï¥àÍ∏∞ÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.' };
      }
    });

    // Ìä∏Î†àÏù¥ ÎÑ§Ïù¥Î≤Ñ Î°úÍ∑∏Ïù∏/Î°úÍ∑∏ÏïÑÏõÉÏùÄ TrayServiceÏóêÏÑú ÏßÅÏ†ë Ï≤òÎ¶¨
    
    // ÎÑ§Ïù¥Î≤Ñ Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú Ìä∏Î†àÏù¥ Î©îÎâ¥ ÏóÖÎç∞Ïù¥Ìä∏
    this.mainWindow?.webContents.on('ipc-message', (event, channel, data) => {
      if (channel === 'update-tray-menu') {
        this.updateTrayMenuWithStatus(data);
      }
    });
  }

  private async migrateExistingData(): Promise<void> {
    try {
      // Í∏∞Ï°¥ JSON ÌååÏùºÎì§Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÍ≥† ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
      const dataDir = path.join(__dirname, '../../data');
      const streamersFile = path.join(dataDir, 'streamers.json');
      const notificationsFile = path.join(dataDir, 'notifications.json');
      const settingsFile = path.join(dataDir, 'settings.json');

      const fs = require('fs').promises;

      // Ïä§Ìä∏Î¶¨Î®∏ Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
      try {
        const streamersData = await fs.readFile(streamersFile, 'utf8');
        const streamers = JSON.parse(streamersData);
        await this.databaseManager.migrateStreamers(streamers);
        console.log('Streamers data migrated successfully');
      } catch (error) {
        console.log('No existing streamers data to migrate');
      }

      // ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
      try {
        const notificationsData = await fs.readFile(notificationsFile, 'utf8');
        const notifications = JSON.parse(notificationsData);
        await this.databaseManager.migrateNotifications(notifications);
        console.log('Notifications data migrated successfully');
      } catch (error) {
        console.log('No existing notifications data to migrate');
      }

      // ÏÑ§Ï†ï Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
      try {
        const settingsData = await fs.readFile(settingsFile, 'utf8');
        const settings = JSON.parse(settingsData);
        await this.settingsService.migrateSettings(settings);
        console.log('Settings data migrated successfully');
      } catch (error) {
        console.log('No existing settings data to migrate');
      }
    } catch (error) {
      console.error('Error during data migration:', error);
    }
  }

  private shouldStartMinimized(): boolean {
    // Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑúÎäî Ìï≠ÏÉÅ Ï∞ΩÏùÑ ÌëúÏãú
    if (this.isDev) {
      return false;
    }
    // Î™ÖÏãúÏ†ÅÏúºÎ°ú --hidden ÌîåÎûòÍ∑∏Í∞Ä ÏûàÏùÑ ÎïåÎßå Ïà®ÍπÄ
    return process.argv.includes('--hidden');
  }

  private shouldMinimizeToTray(): boolean {
    return this.settingsService.getSetting('minimizeToTray') === 'true';
  }

  private async checkAutoStart(): Promise<void> {
    const autoStart = this.settingsService.getSetting('autoStart');
    if (autoStart === 'true') {
      app.setLoginItemSettings({
        openAtLogin: true,
        args: ['--hidden']
      });
    }
  }

  public showMainWindow(): void {
    if (this.mainWindow) {
      if (this.mainWindow.isMinimized()) {
        this.mainWindow.restore();
      }
      this.mainWindow.show();
      this.mainWindow.focus();
    }
  }

  public hideMainWindow(): void {
    if (this.mainWindow) {
      this.mainWindow.hide();
    }
  }

  public quit(): void {
    this.monitoringService.stop();
    app.quit();
  }

  public getMainWindow(): BrowserWindow | null {
    return this.mainWindow;
  }

  private async updateTrayMenu(): Promise<void> {
    try {
      const stats = await this.monitoringService.getMonitoringStats();
      const needNaverLogin = await this.monitoringService.checkNaverLoginStatus();
      
      this.trayService.updateContextMenu({
        ...stats,
        needNaverLogin: needNaverLogin
      });
    } catch (error) {
      console.error('Failed to update tray menu:', error);
    }
  }

  private updateTrayMenuWithStatus(statusData: any): void {
    try {
      console.log('üîÑ Updating tray menu with status:', statusData);
      this.monitoringService.getMonitoringStats().then(stats => {
        this.trayService.updateContextMenu({
          ...stats,
          needNaverLogin: statusData.needNaverLogin
        });
      }).catch(error => {
        console.error('Failed to get monitoring stats for tray update:', error);
        // Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
        this.trayService.updateContextMenu({
          totalStreamers: 0,
          activeStreamers: 0,
          liveStreamers: 0,
          isMonitoring: this.monitoringService.isMonitoring(),
          needNaverLogin: statusData.needNaverLogin
        });
      });
    } catch (error) {
      console.error('Failed to update tray menu with status:', error);
    }
  }

  // MonitoringServiceÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂úÌï† Ïàò ÏûàÎäî Î©îÏÑúÎìú
  updateTrayMenuWithLoginStatus(needLogin: boolean): void {
    try {
      console.log('üîÑ Direct tray menu update: needLogin =', needLogin);
      this.monitoringService.getMonitoringStats().then(stats => {
        this.trayService.updateContextMenu({
          ...stats,
          needNaverLogin: needLogin
        });
      }).catch(error => {
        console.error('Failed to get monitoring stats for direct tray update:', error);
        // Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
        this.trayService.updateContextMenu({
          totalStreamers: 0,
          activeStreamers: 0,
          liveStreamers: 0,
          isMonitoring: this.monitoringService.isMonitoring(),
          needNaverLogin: needLogin
        });
      });
    } catch (error) {
      console.error('Failed to update tray menu with login status:', error);
    }
  }
}

// Ïï± Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Î∞è Ï¥àÍ∏∞Ìôî
const streamerAlarmApp = new StreamerAlarmApp();

// MonitoringServiceÏóêÏÑú Ï†ëÍ∑ºÌï† Ïàò ÏûàÎèÑÎ°ù Ï†ÑÏó≠ Ï∞∏Ï°∞ ÏÑ§Ï†ï
(app as any).streamerAlarmApp = streamerAlarmApp;

// Ïï± Ïù¥Î≤§Ìä∏ Ìï∏Îì§ÎßÅ
app.on('ready', () => {
  console.log('App ready event triggered');
  streamerAlarmApp.initialize().catch((error) => {
    console.error('App initialization failed:', error);
    // Ï¥àÍ∏∞Ìôî Ïã§Ìå® Ïãú Í∞ÑÎã®Ìïú Ï∞ΩÏù¥ÎùºÎèÑ ÌëúÏãú
    const { BrowserWindow } = require('electron');
    const errorWindow = new BrowserWindow({
      width: 600,
      height: 400,
      show: true,
      title: 'Streamer Alarm System - Error'
    });
    errorWindow.loadURL('data:text/html;charset=utf-8,<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body><h1>Ï¥àÍ∏∞Ìôî Ïò§Î•ò</h1><p>Ïï± Ï¥àÍ∏∞Ìôî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.</p><pre>' + error.message + '</pre></body></html>');
  });
});

app.on('window-all-closed', () => {
  // macOSÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ Ïï± Ï¢ÖÎ£å
  if (process.platform !== 'darwin') {
    streamerAlarmApp.quit();
  }
});

app.on('activate', () => {
  // macOSÏóêÏÑú ÎèÖ ÏïÑÏù¥ÏΩò ÌÅ¥Î¶≠ Ïãú ÏúàÎèÑÏö∞ Ïû¨ÏÉùÏÑ±
  if (BrowserWindow.getAllWindows().length === 0) {
    streamerAlarmApp.showMainWindow();
  }
});

app.on('before-quit', () => {
  // Ïï± Ï¢ÖÎ£å Ï†Ñ Ï†ïÎ¶¨ ÏûëÏóÖ
  streamerAlarmApp.quit();
});

// Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑú Ìï´ Î¶¨Î°úÎìú ÏßÄÏõê
if (process.env.NODE_ENV === 'development') {
  // HMR ÏßÄÏõê
}