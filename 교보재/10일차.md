# 10ì¼ì°¨: ì‹œìŠ¤í…œ ì•Œë¦¼ê³¼ íŠ¸ë ˆì´ í†µí•©

## ğŸ“š í•™ìŠµ ëª©í‘œ
- OS ë„¤ì´í‹°ë¸Œ ì•Œë¦¼ ì‹œìŠ¤í…œì˜ ì´í•´ì™€ í™œìš©
- ì‹œìŠ¤í…œ íŠ¸ë ˆì´ êµ¬í˜„ê³¼ ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰ ê´€ë¦¬
- ì•Œë¦¼ ì¤‘ë³µ ë°©ì§€ì™€ ìƒíƒœ ì¶”ì  ì‹œìŠ¤í…œ
- í¬ë¡œìŠ¤ í”Œë«í¼ í˜¸í™˜ì„±ê³¼ ì‚¬ìš©ì ê²½í—˜ ìµœì í™”

## ğŸ”” ì‹œìŠ¤í…œ ì•Œë¦¼ ì•„í‚¤í…ì²˜

### ì•Œë¦¼ ì‹œìŠ¤í…œ ê°œìš”
Streamer Alarm 2ëŠ” ë‹¤ì–‘í•œ í”Œë«í¼ì—ì„œ ì¼ê´€ëœ ì•Œë¦¼ ê²½í—˜ì„ ì œê³µí•˜ê¸° ìœ„í•´ node-notifierë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

**í•µì‹¬ êµ¬ì„± ìš”ì†Œ:**
- **NotificationService**: ì•Œë¦¼ ìƒì„±, ê´€ë¦¬, ì¤‘ë³µ ë°©ì§€
- **TrayService**: ì‹œìŠ¤í…œ íŠ¸ë ˆì´ í†µí•© ë° ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰
- **EventHandlers**: ì•Œë¦¼ í´ë¦­, ì•¡ì…˜ ì²˜ë¦¬
- **ProfileImageCache**: ì•Œë¦¼ ì´ë¯¸ì§€ ìµœì í™” ë° ìºì‹±

### ì‹¤ì œ NotificationService êµ¬ì¡° ë¶„ì„
```typescript
export class NotificationService {
  private databaseManager: DatabaseManager;
  private settingsService: SettingsService;
  private tempDir: string;
  
  // ì¤‘ë³µ ë°©ì§€ ì‹œìŠ¤í…œ
  private activeNotifications: Map<string, NotificationData> = new Map();
  private processedNotifications: Set<string> = new Set();
  private notificationProcessingInProgress: Set<string> = new Set();
  
  // ì´ë²¤íŠ¸ ì²˜ë¦¬ ìƒíƒœ
  private globalHandlersInitialized: boolean = false;

  constructor(databaseManager: DatabaseManager) {
    this.databaseManager = databaseManager;
    this.settingsService = new SettingsService(databaseManager);
    
    // ì„ì‹œ ë””ë ‰í† ë¦¬ ì„¤ì • (í”„ë¡œí•„ ì´ë¯¸ì§€ ìºì‹œìš©)
    const os = require('os');
    this.tempDir = path.join(os.tmpdir(), 'streamer-alarm-profiles');
    this.ensureTempDirectory();
    
    // ê¸€ë¡œë²Œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì •
    this.setupGlobalEventHandlers();
  }
}
```

## ğŸ”§ ì•Œë¦¼ ì¤‘ë³µ ë°©ì§€ ì‹œìŠ¤í…œ

### 1. ë‹¤ì¸µ ì¤‘ë³µ ë°©ì§€ ë©”ì»¤ë‹ˆì¦˜
```typescript
class NotificationService {
  /**
   * ì•± ì‹œì‘ ì‹œ ê¸°ì¡´ ì•Œë¦¼ë“¤ì„ ë¡œë“œí•˜ì—¬ ì¤‘ë³µ ì²´í¬ ì‹œìŠ¤í…œì„ ì´ˆê¸°í™”
   */
  async initializeDuplicateCheck(): Promise<void> {
    try {
      console.log(`[DUPLICATE_INIT] ğŸ”„ Initializing duplicate check system...`);
      
      // ìµœê·¼ 7ì¼ê°„ì˜ ê¸°ì¡´ ì•Œë¦¼ uniqueKey ì¡°íšŒ
      const existingUniqueKeys = await this.databaseManager.getExistingUniqueKeys(7);
      
      console.log(`[DUPLICATE_INIT] ğŸ“‹ Found ${existingUniqueKeys.length} existing notifications`);
      
      // processedNotifications Setì— ê¸°ì¡´ uniqueKeyë“¤ì„ ì¶”ê°€
      existingUniqueKeys.forEach(uniqueKey => {
        this.processedNotifications.add(uniqueKey);
      });
      
      console.log(`[DUPLICATE_INIT] âœ… Duplicate check system initialized with ${this.processedNotifications.size} processed notifications`);
      
    } catch (error) {
      console.error(`[DUPLICATE_INIT] âŒ Failed to initialize duplicate check system:`, error);
    }
  }

  /**
   * ì•Œë¦¼ ì „ì†¡ ì „ ì¤‘ë³µ ê²€ì‚¬
   */
  private async isDuplicateNotification(uniqueKey: string): Promise<boolean> {
    // 1ì°¨: ë©”ëª¨ë¦¬ ê¸°ë°˜ ë¹ ë¥¸ ê²€ì‚¬
    if (this.processedNotifications.has(uniqueKey)) {
      console.log(`[DUPLICATE_CHECK] ğŸš« Duplicate detected in memory: ${uniqueKey}`);
      return true;
    }
    
    // 2ì°¨: í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ì•Œë¦¼ ê²€ì‚¬
    if (this.notificationProcessingInProgress.has(uniqueKey)) {
      console.log(`[DUPLICATE_CHECK] ğŸ”„ Notification currently being processed: ${uniqueKey}`);
      return true;
    }
    
    // 3ì°¨: ë°ì´í„°ë² ì´ìŠ¤ ê¸°ë°˜ ê²€ì‚¬ (ì•ˆì „ì¥ì¹˜)
    const exists = await this.databaseManager.notificationExists(uniqueKey);
    if (exists) {
      console.log(`[DUPLICATE_CHECK] ğŸ—„ï¸ Duplicate detected in database: ${uniqueKey}`);
      // ë©”ëª¨ë¦¬ ìºì‹œì—ë„ ì¶”ê°€
      this.processedNotifications.add(uniqueKey);
      return true;
    }
    
    return false;
  }
}
```

### 2. ê³ ê¸‰ ì•Œë¦¼ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸
```typescript
class NotificationService {
  async sendNotification(notificationData: NotificationData): Promise<void> {
    const uniqueKey = this.generateUniqueKey(notificationData);
    
    try {
      // 1. ì¤‘ë³µ ê²€ì‚¬
      const isDuplicate = await this.isDuplicateNotification(uniqueKey);
      if (isDuplicate) {
        return;
      }
      
      // 2. ì²˜ë¦¬ ì¤‘ ìƒíƒœë¡œ ë§ˆí‚¹
      this.notificationProcessingInProgress.add(uniqueKey);
      
      // 3. ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ (ì‹¤íŒ¨ ì‹œ ë¡¤ë°± ê°€ëŠ¥)
      const savedNotification = await this.databaseManager.addNotification({
        ...notificationData,
        uniqueKey,
        createdAt: new Date().toISOString()
      });
      
      // 4. í”„ë¡œí•„ ì´ë¯¸ì§€ ì²˜ë¦¬
      const profileImagePath = await this.processProfileImage(
        notificationData.profileImageUrl, 
        savedNotification.id
      );
      
      // 5. OS ë„¤ì´í‹°ë¸Œ ì•Œë¦¼ ë°œì†¡
      await this.sendNativeNotification({
        ...notificationData,
        uniqueKey,
        profileImagePath,
        notificationId: savedNotification.id
      });
      
      // 6. ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ëœ ì•Œë¦¼ìœ¼ë¡œ ë§ˆí‚¹
      this.processedNotifications.add(uniqueKey);
      this.activeNotifications.set(uniqueKey, notificationData);
      
      console.log(`[NOTIFICATION] âœ… Successfully sent: ${notificationData.title}`);
      
    } catch (error) {
      console.error(`[NOTIFICATION] âŒ Failed to send notification:`, error);
      
      // ì‹¤íŒ¨ ì‹œ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì œê±° (ë¡¤ë°±)
      try {
        await this.databaseManager.deleteNotificationByUniqueKey(uniqueKey);
      } catch (rollbackError) {
        console.error(`[NOTIFICATION] âŒ Failed to rollback notification:`, rollbackError);
      }
      
      throw error;
    } finally {
      // 7. ì²˜ë¦¬ ì¤‘ ìƒíƒœ í•´ì œ
      this.notificationProcessingInProgress.delete(uniqueKey);
    }
  }

  private generateUniqueKey(notificationData: NotificationData): string {
    // í”Œë«í¼ë³„ ê³ ìœ  í‚¤ ìƒì„±
    const components = [
      notificationData.streamerId?.toString() || notificationData.weverseArtistId?.toString(),
      notificationData.type,
      notificationData.title,
      notificationData.url || 'no-url'
    ].filter(Boolean);
    
    const baseKey = components.join('|');
    return crypto.createHash('md5').update(baseKey).digest('hex');
  }
}
```

### 3. í”„ë¡œí•„ ì´ë¯¸ì§€ ìºì‹± ì‹œìŠ¤í…œ
```typescript
class NotificationService {
  private async processProfileImage(imageUrl?: string, notificationId?: number): Promise<string | undefined> {
    if (!imageUrl) return undefined;
    
    try {
      const fileName = `profile_${notificationId}_${Date.now()}.jpg`;
      const localPath = path.join(this.tempDir, fileName);
      
      // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ë° ìµœì í™”
      const response = await axios.get(imageUrl, {
        responseType: 'arraybuffer',
        timeout: 10000,
        headers: {
          'User-Agent': 'StreamerAlarm/2.0'
        }
      });
      
      let imageBuffer = Buffer.from(response.data);
      
      // ì´ë¯¸ì§€ í¬ê¸° ë° í¬ë§· ìµœì í™” (sharp ì—†ì´ êµ¬í˜„)
      imageBuffer = await this.optimizeImageForNotification(imageBuffer);
      
      // ë¡œì»¬ íŒŒì¼ë¡œ ì €ì¥
      fs.writeFileSync(localPath, imageBuffer);
      
      // ì¼ì • ì‹œê°„ í›„ ìë™ ì •ë¦¬ ìŠ¤ì¼€ì¤„ë§
      this.scheduleImageCleanup(localPath, 300000); // 5ë¶„ í›„ ì‚­ì œ
      
      return localPath;
      
    } catch (error) {
      console.warn(`[IMAGE_CACHE] âš ï¸ Failed to process profile image: ${error.message}`);
      return undefined;
    }
  }

  private async optimizeImageForNotification(imageBuffer: Buffer): Promise<Buffer> {
    // sharp ì—†ì´ ê¸°ë³¸ì ì¸ ì´ë¯¸ì§€ ê²€ì¦ ë° í¬ê¸° ì œí•œ
    const maxSize = 100 * 1024; // 100KB ì œí•œ
    
    if (imageBuffer.length > maxSize) {
      console.warn(`[IMAGE_CACHE] âš ï¸ Image too large (${imageBuffer.length} bytes), using as-is`);
    }
    
    return imageBuffer;
  }

  private scheduleImageCleanup(filePath: string, delay: number): void {
    setTimeout(() => {
      try {
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          console.log(`[IMAGE_CACHE] ğŸ§¹ Cleaned up: ${path.basename(filePath)}`);
        }
      } catch (error) {
        console.warn(`[IMAGE_CACHE] âš ï¸ Failed to cleanup image: ${error.message}`);
      }
    }, delay);
  }
}
```

## ğŸ“± ì‹œìŠ¤í…œ íŠ¸ë ˆì´ êµ¬í˜„

### TrayService êµ¬ì¡° ë¶„ì„
```typescript
export class TrayService {
  private app: any;
  private tray: Tray | null = null;
  private monitoringService: any = null;

  constructor(app: any) {
    this.app = app;
  }

  setMonitoringService(monitoringService: any): void {
    this.monitoringService = monitoringService;
  }

  createTray(): Tray {
    // íŠ¸ë ˆì´ ì•„ì´ì½˜ ìƒì„±
    const iconPath = this.createTrayIcon();
    this.tray = new Tray(iconPath);

    // íˆ´íŒ ì„¤ì •
    this.tray.setToolTip('Streamer Alarm System');

    // ë”ë¸”í´ë¦­ìœ¼ë¡œ ë©”ì¸ ìœˆë„ìš° í‘œì‹œ
    this.tray.on('double-click', () => {
      this.app.showMainWindow();
    });

    // ìš°í´ë¦­ ì‹œ ì‹¤ì‹œê°„ ìƒíƒœ í™•ì¸ í›„ ë©”ë‰´ ì—…ë°ì´íŠ¸
    this.tray.on('right-click', async () => {
      console.log('ğŸ”„ Tray right-clicked, checking latest login status...');
      await this.updateMenuWithLatestStatus();
    });

    // ì´ˆê¸° ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì„¤ì •
    this.updateContextMenu();

    return this.tray;
  }
}
```

### í¬ë¡œìŠ¤ í”Œë«í¼ ì•„ì´ì½˜ ìƒì„±
```typescript
class TrayService {
  private createTrayIcon(): Electron.NativeImage {
    return this.createFallbackIcon();
  }

  private createFallbackIcon(): Electron.NativeImage {
    // í”Œë«í¼ë³„ ìµœì í™”ëœ ì•„ì´ì½˜ ê²½ë¡œë“¤
    const possibleIconPaths = this.getPlatformIconPaths();
    
    for (const iconPath of possibleIconPaths) {
      try {
        console.log(`ğŸ” Trying icon path: ${iconPath}`);
        const fs = require('fs');
        
        if (fs.existsSync(iconPath)) {
          console.log(`âœ… Found icon at: ${iconPath}`);
          const icon = nativeImage.createFromPath(iconPath);
          
          if (!icon.isEmpty()) {
            // í”Œë«í¼ë³„ ìµœì  í¬ê¸°ë¡œ ë¦¬ì‚¬ì´ì¦ˆ
            const iconSize = this.getOptimalIconSize();
            return icon.resize(iconSize);
          }
        } else {
          console.log(`âŒ Icon not found at: ${iconPath}`);
        }
      } catch (error: any) {
        console.warn(`âš ï¸ Failed to load icon from ${iconPath}:`, error.message);
        continue;
      }
    }
    
    console.warn('ğŸ“ All icon paths failed, creating pixel-based fallback icon');
    return this.createPixelIcon();
  }

  private getPlatformIconPaths(): string[] {
    const iconPaths: string[] = [];
    const { app } = require('electron');
    
    // ê°œë°œ í™˜ê²½ ê²½ë¡œë“¤
    const devPaths = [
      path.join(__dirname, '../../assets/icon.png'),
      path.join(__dirname, '../../assets/icon.ico'),
      path.join(__dirname, '../../assets/tray-icon.png'),
      path.join(__dirname, '../../../assets/icon.png'),
      path.join(process.cwd(), 'assets/icon.png'),
      path.join(process.cwd(), 'assets/icon.ico')
    ];
    
    // í”„ë¡œë•ì…˜ í™˜ê²½ ê²½ë¡œë“¤
    const prodPaths = [
      path.join(process.resourcesPath, 'assets/icon.png'),
      path.join(process.resourcesPath, 'assets/icon.ico'),
      path.join(app.getAppPath(), 'assets/icon.png'),
      path.join(app.getAppPath(), 'dist/assets/icon.png')
    ];
    
    return [...devPaths, ...prodPaths];
  }

  private getOptimalIconSize(): { width: number; height: number } {
    // í”Œë«í¼ë³„ ìµœì  ì•„ì´ì½˜ í¬ê¸°
    const platform = process.platform;
    
    switch (platform) {
      case 'win32':
        return { width: 16, height: 16 };
      case 'darwin': // macOS
        return { width: 22, height: 22 };
      case 'linux':
        return { width: 22, height: 22 };
      default:
        return { width: 16, height: 16 };
    }
  }

  private createPixelIcon(): Electron.NativeImage {
    // í”Œë«í¼ë³„ ìµœì  í¬ê¸° ì‚¬ìš©
    const iconSize = this.getOptimalIconSize();
    const { width, height } = iconSize;
    const buffer = Buffer.alloc(width * height * 4); // RGBA
    
    // í”½ì…€ ìƒ‰ìƒ ì •ì˜ (Windows íŠ¸ë ˆì´ì— ì í•©í•œ ìƒ‰ìƒ)
    const darkBlue = [64, 81, 181, 255];    // #4051b5 (Material Blue)
    const lightBlue = [144, 164, 255, 255]; // #90a4ff (Light Blue)
    
    // ê°„ë‹¨í•œ íŒ¨í„´ ìƒì„± (ì˜ˆ: ì²´í¬ë³´ë“œ íŒ¨í„´)
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const index = (y * width + x) * 4;
        const color = (x + y) % 2 === 0 ? darkBlue : lightBlue;
        
        buffer[index] = color[0];     // R
        buffer[index + 1] = color[1]; // G
        buffer[index + 2] = color[2]; // B
        buffer[index + 3] = color[3]; // A
      }
    }
    
    return nativeImage.createFromBuffer(buffer, { width, height });
  }
}
```

### ë™ì  ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
```typescript
class TrayService {
  private async updateMenuWithLatestStatus(): Promise<void> {
    try {
      // ì‹¤ì‹œê°„ ìƒíƒœ í™•ì¸
      const loginStatus = await this.checkCurrentLoginStatus();
      const monitoringStatus = await this.getMonitoringStatus();
      
      this.updateContextMenu(loginStatus, monitoringStatus);
      
    } catch (error) {
      console.error('ğŸš« Failed to update tray menu with latest status:', error);
      // ì—ëŸ¬ ë°œìƒ ì‹œ ê¸°ë³¸ ë©”ë‰´ í‘œì‹œ
      this.updateContextMenu();
    }
  }

  private updateContextMenu(loginStatus?: any, monitoringStatus?: any): void {
    if (!this.tray) return;

    const menuItems: any[] = [
      {
        label: 'Streamer Alarm',
        icon: this.createSmallIcon(),
        enabled: false
      },
      { type: 'separator' },
      {
        label: 'ë©”ì¸ ì°½ ì—´ê¸°',
        click: () => this.app.showMainWindow()
      }
    ];

    // ë¡œê·¸ì¸ ìƒíƒœ ì„¹ì…˜
    if (loginStatus) {
      menuItems.push(
        { type: 'separator' },
        {
          label: 'ë¡œê·¸ì¸ ìƒíƒœ',
          enabled: false
        },
        {
          label: `ë„¤ì´ë²„: ${loginStatus.naver ? 'âœ…' : 'âŒ'}`,
          enabled: false
        },
        {
          label: `ìœ„ë²„ìŠ¤: ${loginStatus.weverse ? 'âœ…' : 'âŒ'}`,
          enabled: false
        }
      );
    }

    // ëª¨ë‹ˆí„°ë§ ìƒíƒœ ì„¹ì…˜
    if (monitoringStatus) {
      menuItems.push(
        { type: 'separator' },
        {
          label: 'ëª¨ë‹ˆí„°ë§ ìƒíƒœ',
          enabled: false
        },
        {
          label: `ìƒíƒœ: ${monitoringStatus.isRunning ? 'ì‹¤í–‰ ì¤‘ ğŸŸ¢' : 'ì¤‘ì§€ë¨ ğŸ”´'}`,
          enabled: false
        }
      );

      // ëª¨ë‹ˆí„°ë§ ì œì–´ ë²„íŠ¼
      if (monitoringStatus.isRunning) {
        menuItems.push({
          label: 'ëª¨ë‹ˆí„°ë§ ì¤‘ì§€',
          click: async () => {
            await this.monitoringService?.stop();
            setTimeout(() => this.updateContextMenu(), 1000);
          }
        });
      } else {
        menuItems.push({
          label: 'ëª¨ë‹ˆí„°ë§ ì‹œì‘',
          click: async () => {
            await this.monitoringService?.start();
            setTimeout(() => this.updateContextMenu(), 1000);
          }
        });
      }
    }

    // í•˜ë‹¨ ê³ ì • ë©”ë‰´ë“¤
    menuItems.push(
      { type: 'separator' },
      {
        label: 'ì„¤ì •',
        click: () => {
          this.app.showMainWindow();
          // ì„¤ì • íƒ­ìœ¼ë¡œ ì´ë™í•˜ëŠ” ì´ë²¤íŠ¸ ë°œì†¡
          this.app.sendToRenderer('navigate-to-settings');
        }
      },
      {
        label: 'ë¡œê·¸ í´ë” ì—´ê¸°',
        click: () => {
          const logPath = path.join(require('electron').app.getPath('userData'), 'logs');
          require('electron').shell.openPath(logPath);
        }
      },
      { type: 'separator' },
      {
        label: 'ì¢…ë£Œ',
        click: () => this.app.quit()
      }
    );

    const contextMenu = Menu.buildFromTemplate(menuItems);
    this.tray.setContextMenu(contextMenu);
  }

  private async checkCurrentLoginStatus(): Promise<any> {
    // ì‹¤ì œ ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸ ë¡œì§
    if (!this.monitoringService) {
      return null;
    }

    try {
      // ê° í”Œë«í¼ë³„ ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸
      const naverStatus = await this.monitoringService.checkNaverLoginStatus?.();
      const weverseStatus = await this.monitoringService.checkWeverseLoginStatus?.();

      return {
        naver: naverStatus?.isLoggedIn || false,
        weverse: weverseStatus?.isLoggedIn || false
      };
    } catch (error) {
      console.warn('Failed to check login status:', error);
      return null;
    }
  }

  private async getMonitoringStatus(): Promise<any> {
    if (!this.monitoringService) {
      return { isRunning: false };
    }

    try {
      return {
        isRunning: this.monitoringService.isRunning || false,
        lastCheck: this.monitoringService.getLastCheckTime?.() || null
      };
    } catch (error) {
      console.warn('Failed to get monitoring status:', error);
      return { isRunning: false };
    }
  }
}
```

## ğŸ”— ì´ë²¤íŠ¸ ì²˜ë¦¬ì™€ ìƒí˜¸ì‘ìš©

### ê¸€ë¡œë²Œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
```typescript
class NotificationService {
  private setupGlobalEventHandlers(): void {
    if (this.globalHandlersInitialized) {
      return;
    }

    console.log(`[DEBUG] ===== SETTING UP GLOBAL NOTIFICATION HANDLERS =====`);
    
    try {
      // ê¸€ë¡œë²Œ í´ë¦­ í•¸ë“¤ëŸ¬
      notifier.on('click', async (...args: any[]) => {
        console.log(`[GLOBAL_CLICK] *** CLICK EVENT DETECTED ***`);
        console.log(`[GLOBAL_CLICK] Arguments:`, args);
        await this.handleGlobalClick(...args);
      });

      // ê¸€ë¡œë²Œ ì•¡ì…˜ í•¸ë“¤ëŸ¬  
      notifier.on('action', async (...args: any[]) => {
        console.log(`[GLOBAL_ACTION] *** ACTION EVENT DETECTED ***`);
        console.log(`[GLOBAL_ACTION] Arguments:`, args);
        await this.handleGlobalAction(...args);
      });

      // íƒ€ì„ì•„ì›ƒ í•¸ë“¤ëŸ¬
      notifier.on('timeout', (...args: any[]) => {
        console.log(`[GLOBAL_TIMEOUT] *** TIMEOUT EVENT DETECTED ***`);
        console.log(`[GLOBAL_TIMEOUT] Arguments:`, args);
        this.handleGlobalTimeout(...args);
      });

      this.globalHandlersInitialized = true;
      console.log(`[DEBUG] âœ… All global handlers registered successfully`);

    } catch (error) {
      console.error(`[DEBUG] âŒ Failed to setup global handlers:`, error);
      throw error;
    }
  }

  private async handleGlobalClick(...args: any[]): Promise<void> {
    try {
      // í´ë¦­ëœ ì•Œë¦¼ ì‹ë³„
      const notificationData = this.extractNotificationFromArgs(args);
      
      if (notificationData?.url) {
        console.log(`[CLICK_HANDLER] Opening URL: ${notificationData.url}`);
        await shell.openExternal(notificationData.url);
      }

      // ë©”ì¸ ìœˆë„ìš° í‘œì‹œ
      const mainWindow = BrowserWindow.getAllWindows()[0];
      if (mainWindow) {
        if (mainWindow.isMinimized()) {
          mainWindow.restore();
        }
        mainWindow.show();
        mainWindow.focus();
      }

      // ì•Œë¦¼ì„ ì½ìŒ ìƒíƒœë¡œ ë³€ê²½
      if (notificationData?.uniqueKey) {
        await this.markNotificationAsRead(notificationData.uniqueKey);
      }

    } catch (error) {
      console.error(`[CLICK_HANDLER] âŒ Error handling click:`, error);
    }
  }

  private async handleGlobalAction(...args: any[]): Promise<void> {
    try {
      const [actionType, notificationObj] = args;
      
      console.log(`[ACTION_HANDLER] Action type: ${actionType}`);
      
      switch (actionType) {
        case 'open_url':
          if (notificationObj?.url) {
            await shell.openExternal(notificationObj.url);
          }
          break;
          
        case 'mark_read':
          if (notificationObj?.uniqueKey) {
            await this.markNotificationAsRead(notificationObj.uniqueKey);
          }
          break;
          
        case 'dismiss':
          // ì•Œë¦¼ í•´ì œ ì²˜ë¦¬
          if (notificationObj?.uniqueKey) {
            this.activeNotifications.delete(notificationObj.uniqueKey);
          }
          break;
          
        default:
          console.log(`[ACTION_HANDLER] Unknown action: ${actionType}`);
      }
      
    } catch (error) {
      console.error(`[ACTION_HANDLER] âŒ Error handling action:`, error);
    }
  }

  private handleGlobalTimeout(...args: any[]): void {
    console.log(`[TIMEOUT_HANDLER] Notification timed out`);
    
    // íƒ€ì„ì•„ì›ƒëœ ì•Œë¦¼ ì •ë¦¬
    const notificationData = this.extractNotificationFromArgs(args);
    if (notificationData?.uniqueKey) {
      this.activeNotifications.delete(notificationData.uniqueKey);
    }
  }

  private extractNotificationFromArgs(args: any[]): any {
    // node-notifierì˜ ì´ë²¤íŠ¸ argumentsì—ì„œ ì•Œë¦¼ ë°ì´í„° ì¶”ì¶œ
    for (const arg of args) {
      if (arg && typeof arg === 'object') {
        if (arg.uniqueKey || arg.notificationId) {
          return arg;
        }
        
        // ë¬¸ìì—´ì—ì„œ uniqueKey ì¶”ì¶œ ì‹œë„
        if (typeof arg === 'string' && arg.includes('uniqueKey:')) {
          const match = arg.match(/uniqueKey:([^;]+)/);
          if (match) {
            const uniqueKey = match[1];
            return this.activeNotifications.get(uniqueKey);
          }
        }
      }
    }
    
    return null;
  }
}
```

## ğŸ“‹ ì‹¤ìŠµ: ê³ ê¸‰ ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬í˜„

### ì‹¤ìŠµ 1: ì•Œë¦¼ í…œí”Œë¦¿ ì‹œìŠ¤í…œ
```typescript
// src/main/services/NotificationTemplateService.ts
export interface NotificationTemplate {
  id: string;
  title: string;
  messageTemplate: string;
  iconType: 'live' | 'post' | 'tweet' | 'general';
  actions?: NotificationAction[];
  sound?: boolean;
  priority?: 'low' | 'normal' | 'high';
}

export interface NotificationAction {
  type: string;
  title: string;
  handler: string;
}

export class NotificationTemplateService {
  private templates: Map<string, NotificationTemplate> = new Map();

  constructor() {
    this.initializeDefaultTemplates();
  }

  private initializeDefaultTemplates(): void {
    // ë¼ì´ë¸Œ ìŠ¤íŠ¸ë¦¼ ì‹œì‘ í…œí”Œë¦¿
    this.templates.set('stream_started', {
      id: 'stream_started',
      title: 'ğŸ”´ {streamerName} ë¼ì´ë¸Œ ì‹œì‘!',
      messageTemplate: '{streamerName}ë‹˜ì´ ë°©ì†¡ì„ ì‹œì‘í–ˆìŠµë‹ˆë‹¤!\nì œëª©: {streamTitle}',
      iconType: 'live',
      actions: [
        {
          type: 'open_stream',
          title: 'ë°©ì†¡ ë³´ê¸°',
          handler: 'openStreamUrl'
        },
        {
          type: 'remind_later',
          title: 'ë‚˜ì¤‘ì— ì•Œë¦¼',
          handler: 'scheduleReminder'
        }
      ],
      sound: true,
      priority: 'high'
    });

    // ìƒˆ ê²Œì‹œê¸€ í…œí”Œë¦¿
    this.templates.set('new_post', {
      id: 'new_post',
      title: 'ğŸ“ {streamerName} ìƒˆ ê²Œì‹œê¸€',
      messageTemplate: '{postTitle}\n\n{postPreview}',
      iconType: 'post',
      actions: [
        {
          type: 'open_post',
          title: 'ê²Œì‹œê¸€ ë³´ê¸°',
          handler: 'openPostUrl'
        }
      ],
      sound: false,
      priority: 'normal'
    });

    // íŠ¸ìœ„í„° ì—…ë°ì´íŠ¸ í…œí”Œë¦¿
    this.templates.set('twitter_update', {
      id: 'twitter_update',
      title: 'ğŸ¦ {streamerName} íŠ¸ìœ—',
      messageTemplate: '{tweetText}',
      iconType: 'tweet',
      actions: [
        {
          type: 'open_tweet',
          title: 'íŠ¸ìœ— ë³´ê¸°',
          handler: 'openTweetUrl'
        },
        {
          type: 'retweet',
          title: 'ë¦¬íŠ¸ìœ—',
          handler: 'retweetPost'
        }
      ],
      sound: false,
      priority: 'normal'
    });
  }

  getTemplate(templateId: string): NotificationTemplate | null {
    return this.templates.get(templateId) || null;
  }

  renderNotification(templateId: string, data: any): NotificationData | null {
    const template = this.getTemplate(templateId);
    if (!template) {
      return null;
    }

    // í…œí”Œë¦¿ ë³€ìˆ˜ ì¹˜í™˜
    const title = this.replaceVariables(template.title, data);
    const message = this.replaceVariables(template.messageTemplate, data);

    return {
      title,
      message,
      iconType: template.iconType,
      actions: template.actions,
      sound: template.sound,
      priority: template.priority,
      ...data
    };
  }

  private replaceVariables(template: string, data: any): string {
    let result = template;
    
    // ë³€ìˆ˜ íŒ¨í„´ {variableName} ì„ ì‹¤ì œ ê°’ìœ¼ë¡œ ì¹˜í™˜
    const variablePattern = /\{(\w+)\}/g;
    
    result = result.replace(variablePattern, (match, variableName) => {
      return data[variableName] || match;
    });

    return result;
  }
}
```

### ì‹¤ìŠµ 2: ì•Œë¦¼ ìš°ì„ ìˆœìœ„ ë° ìŠ¤ì¼€ì¤„ë§
```typescript
// src/main/services/NotificationScheduler.ts
export interface ScheduledNotification {
  id: string;
  notification: NotificationData;
  scheduledTime: Date;
  priority: number;
  attempts: number;
  maxAttempts: number;
}

export class NotificationScheduler {
  private queue: ScheduledNotification[] = [];
  private processing: boolean = false;
  private intervalId: NodeJS.Timeout | null = null;
  private notificationService: NotificationService;

  constructor(notificationService: NotificationService) {
    this.notificationService = notificationService;
    this.startProcessing();
  }

  scheduleNotification(
    notification: NotificationData, 
    delay: number = 0, 
    priority: number = 1
  ): string {
    const scheduledNotification: ScheduledNotification = {
      id: crypto.randomUUID(),
      notification,
      scheduledTime: new Date(Date.now() + delay),
      priority,
      attempts: 0,
      maxAttempts: 3
    };

    // ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì •ë ¬í•˜ì—¬ ì‚½ì…
    this.insertByPriority(scheduledNotification);
    
    console.log(`[SCHEDULER] Scheduled notification: ${notification.title} (Priority: ${priority})`);
    
    return scheduledNotification.id;
  }

  private insertByPriority(scheduledNotification: ScheduledNotification): void {
    let insertIndex = this.queue.length;
    
    // ìš°ì„ ìˆœìœ„ê°€ ë†’ì€(ìˆ«ìê°€ í°) ìˆœì„œë¡œ ì •ë ¬
    for (let i = 0; i < this.queue.length; i++) {
      if (this.queue[i].priority < scheduledNotification.priority) {
        insertIndex = i;
        break;
      }
    }
    
    this.queue.splice(insertIndex, 0, scheduledNotification);
  }

  cancelNotification(id: string): boolean {
    const index = this.queue.findIndex(item => item.id === id);
    if (index !== -1) {
      this.queue.splice(index, 1);
      console.log(`[SCHEDULER] Cancelled notification: ${id}`);
      return true;
    }
    return false;
  }

  private startProcessing(): void {
    if (this.intervalId) return;
    
    this.intervalId = setInterval(() => {
      this.processQueue();
    }, 1000); // 1ì´ˆë§ˆë‹¤ ì²˜ë¦¬
  }

  private async processQueue(): Promise<void> {
    if (this.processing || this.queue.length === 0) {
      return;
    }

    this.processing = true;

    try {
      const now = new Date();
      const readyNotifications = this.queue.filter(
        item => item.scheduledTime <= now
      );

      for (const scheduledNotification of readyNotifications) {
        try {
          await this.notificationService.sendNotification(scheduledNotification.notification);
          
          // ì„±ê³µì ìœ¼ë¡œ ì „ì†¡ëœ ì•Œë¦¼ ì œê±°
          this.removeFromQueue(scheduledNotification.id);
          
          console.log(`[SCHEDULER] Successfully sent scheduled notification: ${scheduledNotification.notification.title}`);
          
        } catch (error) {
          console.error(`[SCHEDULER] Failed to send notification:`, error);
          
          // ì¬ì‹œë„ ë¡œì§
          scheduledNotification.attempts++;
          
          if (scheduledNotification.attempts >= scheduledNotification.maxAttempts) {
            console.error(`[SCHEDULER] Max attempts reached, removing notification: ${scheduledNotification.notification.title}`);
            this.removeFromQueue(scheduledNotification.id);
          } else {
            // ì¬ì‹œë„ ìŠ¤ì¼€ì¤„ë§ (ì§€ìˆ˜ ë°±ì˜¤í”„)
            const retryDelay = Math.pow(2, scheduledNotification.attempts) * 1000;
            scheduledNotification.scheduledTime = new Date(Date.now() + retryDelay);
            
            console.log(`[SCHEDULER] Retrying notification in ${retryDelay}ms (Attempt ${scheduledNotification.attempts}/${scheduledNotification.maxAttempts})`);
          }
        }
      }
    } finally {
      this.processing = false;
    }
  }

  private removeFromQueue(id: string): void {
    const index = this.queue.findIndex(item => item.id === id);
    if (index !== -1) {
      this.queue.splice(index, 1);
    }
  }

  getQueueStatus(): { pending: number; processing: boolean } {
    return {
      pending: this.queue.length,
      processing: this.processing
    };
  }

  stop(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
}
```

### ì‹¤ìŠµ 3: ì•Œë¦¼ í†µê³„ ë° ë¶„ì„
```typescript
// src/main/services/NotificationAnalytics.ts
export interface NotificationStats {
  totalSent: number;
  totalClicked: number;
  clickRate: number;
  platformBreakdown: { [platform: string]: number };
  hourlyDistribution: number[];
  recentActivity: NotificationActivity[];
}

export interface NotificationActivity {
  timestamp: Date;
  type: 'sent' | 'clicked' | 'dismissed';
  notificationId: string;
  platform: string;
}

export class NotificationAnalytics {
  private activities: NotificationActivity[] = [];
  private maxActivities: number = 1000;
  private databaseManager: DatabaseManager;

  constructor(databaseManager: DatabaseManager) {
    this.databaseManager = databaseManager;
  }

  recordActivity(activity: Omit<NotificationActivity, 'timestamp'>): void {
    const activityWithTimestamp: NotificationActivity = {
      ...activity,
      timestamp: new Date()
    };

    this.activities.push(activityWithTimestamp);

    // ìµœëŒ€ ê°œìˆ˜ ì œí•œ
    if (this.activities.length > this.maxActivities) {
      this.activities.shift();
    }

    // ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
    this.saveActivityToDatabase(activityWithTimestamp);
  }

  private async saveActivityToDatabase(activity: NotificationActivity): Promise<void> {
    try {
      // í™œë™ ë¡œê·¸ë¥¼ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥í•˜ëŠ” ë¡œì§
      await this.databaseManager.saveNotificationActivity(activity);
    } catch (error) {
      console.error('[ANALYTICS] Failed to save activity to database:', error);
    }
  }

  async getStats(days: number = 7): Promise<NotificationStats> {
    const cutoffDate = new Date(Date.now() - (days * 24 * 60 * 60 * 1000));
    
    // ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ í†µê³„ ì¡°íšŒ
    const dbStats = await this.databaseManager.getNotificationStats(cutoffDate);
    
    // ë©”ëª¨ë¦¬ í™œë™ ë¡œê·¸ í•„í„°ë§
    const recentActivities = this.activities.filter(
      activity => activity.timestamp >= cutoffDate
    );

    const totalSent = dbStats.totalSent + recentActivities.filter(a => a.type === 'sent').length;
    const totalClicked = dbStats.totalClicked + recentActivities.filter(a => a.type === 'clicked').length;
    
    return {
      totalSent,
      totalClicked,
      clickRate: totalSent > 0 ? (totalClicked / totalSent) * 100 : 0,
      platformBreakdown: this.calculatePlatformBreakdown(dbStats, recentActivities),
      hourlyDistribution: this.calculateHourlyDistribution(dbStats, recentActivities),
      recentActivity: recentActivities.slice(-50) // ìµœê·¼ 50ê°œ
    };
  }

  private calculatePlatformBreakdown(dbStats: any, recentActivities: NotificationActivity[]): { [platform: string]: number } {
    const breakdown = { ...dbStats.platformBreakdown };

    recentActivities
      .filter(activity => activity.type === 'sent')
      .forEach(activity => {
        breakdown[activity.platform] = (breakdown[activity.platform] || 0) + 1;
      });

    return breakdown;
  }

  private calculateHourlyDistribution(dbStats: any, recentActivities: NotificationActivity[]): number[] {
    const hourlyCount = new Array(24).fill(0);
    
    // ë°ì´í„°ë² ì´ìŠ¤ í†µê³„ ë°˜ì˜
    if (dbStats.hourlyDistribution) {
      for (let i = 0; i < 24; i++) {
        hourlyCount[i] += dbStats.hourlyDistribution[i] || 0;
      }
    }

    // ë©”ëª¨ë¦¬ í™œë™ ë°˜ì˜
    recentActivities
      .filter(activity => activity.type === 'sent')
      .forEach(activity => {
        const hour = activity.timestamp.getHours();
        hourlyCount[hour]++;
      });

    return hourlyCount;
  }

  getClickRate(platform?: string): number {
    const activities = platform 
      ? this.activities.filter(a => a.platform === platform)
      : this.activities;

    const sent = activities.filter(a => a.type === 'sent').length;
    const clicked = activities.filter(a => a.type === 'clicked').length;

    return sent > 0 ? (clicked / sent) * 100 : 0;
  }

  getMostActiveHours(): number[] {
    const hourlyCount = this.calculateHourlyDistribution({}, this.activities);
    
    return hourlyCount
      .map((count, hour) => ({ hour, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 3)
      .map(item => item.hour);
  }
}
```

## ğŸ“‹ ì‹¤ìŠµ ê³¼ì œ

### ê¸°ë³¸ ê³¼ì œ
1. **ì•Œë¦¼ í…œí”Œë¦¿**: ë‹¤ì–‘í•œ í”Œë«í¼ë³„ ì•Œë¦¼ í…œí”Œë¦¿ ì‹œìŠ¤í…œ êµ¬í˜„
2. **íŠ¸ë ˆì´ ë©”ë‰´**: ì‹¤ì‹œê°„ ìƒíƒœê°€ ë°˜ì˜ë˜ëŠ” ë™ì  íŠ¸ë ˆì´ ë©”ë‰´ êµ¬í˜„
3. **ì´ë²¤íŠ¸ ì²˜ë¦¬**: ì•Œë¦¼ í´ë¦­, ì•¡ì…˜ ë²„íŠ¼ ì²˜ë¦¬ ì‹œìŠ¤í…œ
4. **ì´ë¯¸ì§€ ìºì‹±**: í”„ë¡œí•„ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ë° ìµœì í™” ì‹œìŠ¤í…œ

### ì‘ìš© ê³¼ì œ
1. **ì•Œë¦¼ ìŠ¤ì¼€ì¤„ë§**: ì‚¬ìš©ì í™œì„± ì‹œê°„ ê¸°ë°˜ ì§€ëŠ¥í˜• ì•Œë¦¼ ìŠ¤ì¼€ì¤„ë§
2. **í†µê³„ ë° ë¶„ì„**: ì•Œë¦¼ íš¨ê³¼ ë¶„ì„ ë° ìµœì í™” ì œì•ˆ ì‹œìŠ¤í…œ
3. **ë‹¤êµ­ì–´ ì§€ì›**: i18nì„ í™œìš©í•œ ë‹¤êµ­ì–´ ì•Œë¦¼ ì‹œìŠ¤í…œ
4. **ì ‘ê·¼ì„±**: ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì› ë° ì ‘ê·¼ì„± ê°œì„ 

### ë„ì „ ê³¼ì œ
1. **ë¨¸ì‹ ëŸ¬ë‹**: ì‚¬ìš©ì í–‰ë™ íŒ¨í„´ í•™ìŠµ ê¸°ë°˜ ì•Œë¦¼ ìµœì í™”
2. **í´ë¼ìš°ë“œ ë™ê¸°í™”**: ì—¬ëŸ¬ ë””ë°”ì´ìŠ¤ ê°„ ì•Œë¦¼ ìƒíƒœ ë™ê¸°í™”
3. **ì›¹ í‘¸ì‹œ**: PWAì™€ ì—°ë™í•œ ì›¹ í‘¸ì‹œ ì•Œë¦¼ ì‹œìŠ¤í…œ
4. **ì„ë² ë””ë“œ ë·°**: ì•Œë¦¼ ë‚´ ì¸í„°ë™í‹°ë¸Œ ì½˜í…ì¸  í‘œì‹œ

## ğŸ¯ í•™ìŠµ ì •ë¦¬

### í•µì‹¬ ê°œë… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] **OS ì•Œë¦¼ ì‹œìŠ¤í…œ**: node-notifierë¥¼ í†µí•œ ë„¤ì´í‹°ë¸Œ ì•Œë¦¼ êµ¬í˜„
- [ ] **ì¤‘ë³µ ë°©ì§€**: ë‹¤ì¸µ ì¤‘ë³µ ë°©ì§€ ë©”ì»¤ë‹ˆì¦˜ê³¼ ìƒíƒœ ì¶”ì 
- [ ] **íŠ¸ë ˆì´ í†µí•©**: ì‹œìŠ¤í…œ íŠ¸ë ˆì´ì™€ ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰ ê´€ë¦¬
- [ ] **ì´ë²¤íŠ¸ ì²˜ë¦¬**: ì•Œë¦¼ ìƒí˜¸ì‘ìš©ê³¼ ì‚¬ìš©ì ì•¡ì…˜ ì²˜ë¦¬
- [ ] **í¬ë¡œìŠ¤ í”Œë«í¼**: í”Œë«í¼ë³„ ìµœì í™”ì™€ í˜¸í™˜ì„±

### ì‹¤ë¬´ ì ìš© í¬ì¸íŠ¸
1. **ì‚¬ìš©ì ê²½í—˜**: ì ì ˆí•œ íƒ€ì´ë°ê³¼ ë¹ˆë„ì˜ ì•Œë¦¼ ë°œì†¡
2. **ì„±ëŠ¥ ìµœì í™”**: ì´ë¯¸ì§€ ìºì‹±ê³¼ ë©”ëª¨ë¦¬ ê´€ë¦¬
3. **ì•ˆì •ì„±**: ì—ëŸ¬ ì²˜ë¦¬ì™€ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜
4. **ë¶„ì„**: ì•Œë¦¼ íš¨ê³¼ ì¸¡ì •ê³¼ ê°œì„  ë°©í–¥ ë„ì¶œ

---
*ğŸ”” **10ì¼ì°¨ ì™„ë£Œ!** ì‹œìŠ¤í…œ ìˆ˜ì¤€ì˜ ì•Œë¦¼ê³¼ íŠ¸ë ˆì´ í†µí•©ì„ í†µí•´ ë„¤ì´í‹°ë¸Œí•œ ë°ìŠ¤í¬í†± ì• í”Œë¦¬ì¼€ì´ì…˜ ê²½í—˜ì„ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë‹¨ê³„ì—ì„œëŠ” ì™¸ë¶€ API í†µí•©ê³¼ ì›¹ ìŠ¤í¬ë˜í•‘ì„ í†µí•œ ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘ì„ ë‹¤ë¤„ë³´ê² ìŠµë‹ˆë‹¤.*