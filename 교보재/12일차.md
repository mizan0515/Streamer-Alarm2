# âš¡ 12ì¼ì°¨: ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

> **í•™ìŠµ ëª©í‘œ**: ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ë¥¼ í™œìš©í•œ ëŒ€ìš©ëŸ‰ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ êµ¬í˜„ê³¼ ì„±ëŠ¥ ìµœì í™”

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

### í•µì‹¬ ëª©í‘œ
- ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜(Event-Driven Architecture) êµ¬í˜„
- ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì˜ ì„±ëŠ¥ ìµœì í™”
- ë©”ëª¨ë¦¬ ê´€ë¦¬ì™€ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„
- ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ì™€ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ

### ì‹¤ë¬´ ì—­ëŸ‰
- ì ˆì „ëª¨ë“œ ê°ì§€ì™€ ë³µêµ¬ ì‹œìŠ¤í…œ ì„¤ê³„
- ì„¸ì…˜ ë¬´ê²°ì„± ê²€ì¦ê³¼ ìë™ ë³µêµ¬
- ë©€í‹°í”Œë«í¼ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ í†µí•©
- ì‹¤ì‹œê°„ ì•Œë¦¼ê³¼ UI ë™ê¸°í™”

---

## ğŸ“š ì´ë¡  í•™ìŠµ

### 1. ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ (Event-Driven Architecture)

#### ì „í†µì ì¸ í˜¸ì¶œ ë°©ì‹ì˜ í•œê³„
```typescript
// ì „í†µì ì¸ ë°©ì‹ - ê°•ê²°í•©
class TraditionalMonitoring {
  checkAllPlatforms(): void {
    const liveStatus = this.chzzkMonitor.check();  // ë™ê¸°ì  í˜¸ì¶œ
    const tweets = this.twitterMonitor.check();    // ìˆœì°¨ì  ì²˜ë¦¬
    const posts = this.cafeMonitor.check();        // ì˜ì¡´ì„± ì¦ê°€
    
    this.notificationService.send(liveStatus);     // ì§ì ‘ í˜¸ì¶œ
    this.updateUI(tweets, posts);                  // ê°•ê²°í•©
  }
}
```

#### ì´ë²¤íŠ¸ ê¸°ë°˜ ì ‘ê·¼ë²•ì˜ ì¥ì 
```typescript
// ì´ë²¤íŠ¸ ê¸°ë°˜ ë°©ì‹ - ëŠìŠ¨í•œ ê²°í•©
class EventDrivenMonitoring extends EventEmitter {
  start(): void {
    // ê° ëª¨ë‹ˆí„°ëŠ” ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰
    this.chzzkMonitor.on('live-status-change', this.handleLiveStatus.bind(this));
    this.twitterMonitor.on('new-tweet', this.handleNewTweet.bind(this));
    this.cafeMonitor.on('new-post', this.handleNewPost.bind(this));
    
    // ë³‘ë ¬ ì‹¤í–‰
    Promise.all([
      this.chzzkMonitor.start(),
      this.twitterMonitor.start(),
      this.cafeMonitor.start()
    ]);
  }
  
  private handleLiveStatus(data: LiveStatusData): void {
    this.emit('streamer-status-updated', data);
    // ë‹¤ë¥¸ ì»´í¬ë„ŒíŠ¸ë“¤ì´ í•„ìš”ì— ë”°ë¼ ë°˜ì‘
  }
}
```

### 2. ì‹¤ì‹œê°„ ìƒíƒœ ê´€ë¦¬ íŒ¨í„´

#### ìƒíƒœ ì§€ì†ì„± (State Persistence)
```typescript
interface MonitorState {
  streamerId: number;
  platform: string;
  lastStatus: string;
  lastContentId: string;
  lastCheckTime: number;
}

class StateManager {
  private memoryCache = new Map<string, MonitorState>();
  
  async restoreState(): Promise<void> {
    const states = await this.databaseManager.getAllMonitorStates();
    states.forEach(state => {
      const key = `${state.streamerId}_${state.platform}`;
      this.memoryCache.set(key, state);
    });
  }
  
  async persistState(streamerId: number, platform: string, data: Partial<MonitorState>): Promise<void> {
    const key = `${streamerId}_${platform}`;
    const existing = this.memoryCache.get(key) || {};
    const updated = { ...existing, ...data, lastCheckTime: Date.now() };
    
    this.memoryCache.set(key, updated);
    await this.databaseManager.saveMonitorState(updated);
  }
}
```

#### ì ˆì „ëª¨ë“œ ê°ì§€ì™€ ë³µêµ¬
```typescript
class SleepDetector {
  private lastCheckTime: number = Date.now();
  private readonly SLEEP_THRESHOLD = 10 * 60 * 1000; // 10ë¶„
  
  checkForSleep(): boolean {
    const now = Date.now();
    const gap = now - this.lastCheckTime;
    
    if (gap > this.SLEEP_THRESHOLD) {
      console.log(`ğŸ’¤ Sleep detected: ${Math.round(gap / 1000)}s gap`);
      return true;
    }
    
    this.lastCheckTime = now;
    return false;
  }
  
  async recoverFromSleep(): Promise<void> {
    console.log('ğŸ”„ Recovering from sleep mode...');
    
    // 1. ì„¸ì…˜ ì¬ê²€ì¦
    await this.validateAllSessions();
    
    // 2. ëˆ„ë½ëœ ì•Œë¦¼ ë³µêµ¬
    await this.recoverMissedNotifications();
    
    // 3. ë¸Œë¼ìš°ì € í’€ ìƒíƒœ í™•ì¸
    await this.browserPoolManager.validateInstances();
  }
}
```

---

## ğŸ” ì½”ë“œ ë¶„ì„

### 1. MonitoringService í•µì‹¬ ì•„í‚¤í…ì²˜

#### í†µí•© ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ êµ¬ì¡°
```typescript
export class MonitoringService {
  private databaseManager: DatabaseManager;
  private notificationService: NotificationService;
  private settingsService: SettingsService;
  private browserPoolManager: BrowserPoolManager;
  
  // ê° í”Œë«í¼ë³„ ëª¨ë‹ˆí„°
  public chzzkMonitor: ChzzkMonitor;
  private twitterMonitor: TwitterMonitor;
  private cafeMonitor: CafeMonitor;
  private weverseMonitor: WeiverseMonitor;
  
  // ìƒíƒœ ê´€ë¦¬
  private isRunning: boolean = false;
  private monitoringInterval: NodeJS.Timeout | null = null;
  private lastMonitoringTime: number = 0;
  private sleepDetectionThreshold: number = 600000; // 10ë¶„
  private isInitialStart: boolean = true;
  
  // ìœ„ë²„ìŠ¤ ì„¸ì…˜ ê´€ë¦¬
  private lastWeverseSessionCheck: number = 0;
  private weverseSessionCheckInterval: number = 10 * 60 * 1000; // 10ë¶„
  
  // ë„¤ì´ë²„ ë¡œê·¸ì¸ ìƒíƒœ ê´€ë¦¬
  private naverLoginStatus: boolean | null = null;
  private statusCheckInterval: NodeJS.Timeout | null = null;
  private statusCheckInProgress: boolean = false;
}
```

#### ì‹œìŠ¤í…œ ì‹œì‘ê³¼ ì´ˆê¸°í™” ë¡œì§
```typescript
async start(): Promise<boolean> {
  if (this.isRunning) {
    return true;
  }

  try {
    this.isRunning = true;
    this.lastMonitoringTime = Date.now();
    
    // 1. ë¸Œë¼ìš°ì € í’€ ë§¤ë‹ˆì € ì´ˆê¸°í™”
    console.log('ğŸ”§ Initializing Browser Pool Manager...');
    await this.browserPoolManager.initialize();
    
    // 2. ëª¨ë‹ˆí„°ë§ ìƒíƒœ ì´ˆê¸°í™” (ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€ë¥¼ ìœ„í•œ ê¸°ì¤€ì„  ì„¤ì •)
    await this.databaseManager.initializeMonitorStates();
    
    // 3. ì´ì „ ìƒíƒœ ë³µì› (ì•± ì¬ì‹œì‘ ì‹œ)
    await this.restoreMonitoringStates();
    
    // 4. ëª¨ë‹ˆí„°ë“¤ì— ë¸Œë¼ìš°ì € í’€ ë§¤ë‹ˆì € ì„¤ì •
    this.cafeMonitor.setBrowserPoolManager(this.browserPoolManager);
    this.weverseMonitor.setBrowserPoolManager(this.browserPoolManager);
    
    // 5. ê° ëª¨ë‹ˆí„° ì´ˆê¸°í™”
    await this.cafeMonitor.initialize();
    await this.twitterMonitor.checkInstanceHealth();
    await this.weverseMonitor.initialize();
    
    // 6. ë¡œê·¸ì¸ ìƒíƒœ ê´€ë¦¬ ì‹œì‘
    await this.initializeLoginStatus();
    this.startLoginStatusMonitoring();
    
    // 7. ìƒˆ ìŠ¤íŠ¸ë¦¬ë¨¸ë“¤ì˜ ê¸°ì¤€ì„  ì„¤ì • (ë¬´ìŒ ëª¨ë“œ)
    await this.establishBaselinesForNewStreamers();
    
    console.log('Monitoring service started with state persistence');
    
    // 8. ì•± ì¬ì‹œì‘ ì‹œ ëˆ„ë½ëœ ì•Œë¦¼ ë³µêµ¬
    console.log('ğŸ”„ App restart detected, recovering missed notifications...');
    await this.recoverMissedNotifications();
    
    // 9. ì²« ì²´í¬ë¥¼ 15ì´ˆ í›„ì— ì‹¤í–‰ (ê¸°ì¤€ì„  ì„¤ì • ì™„ë£Œ í›„)
    setTimeout(async () => {
      this.isInitialStart = false;
      await this.performMonitoringCheck();
      this.scheduleNextCheck();
    }, 15000);
    
    return true;
  } catch (error) {
    console.error('Failed to start monitoring:', error);
    this.isRunning = false;
    return false;
  }
}
```

### 2. ìƒíƒœ ë³µì› ë©”ì»¤ë‹ˆì¦˜

#### ëª¨ë‹ˆí„°ë§ ìƒíƒœ ë³µì›
```typescript
private async restoreMonitoringStates(): Promise<void> {
  try {
    console.log('ğŸ”„ Restoring monitoring states from database...');
    
    const streamers = await this.databaseManager.getStreamers();
    let statesRestored = 0;
    
    for (const streamer of streamers) {
      if (!streamer.isActive) continue;
      
      // CHZZK ìƒíƒœ ë³µì›
      if (streamer.chzzkId) {
        const chzzkState = await this.databaseManager.getMonitorState(streamer.id, 'chzzk');
        if (chzzkState?.lastStatus === 'live') {
          // ë©”ëª¨ë¦¬ ìºì‹œì— ë¼ì´ë¸Œ ìƒíƒœ ë³µì›
          this.chzzkMonitor['previousLiveStatus'].set(streamer.id.toString(), true);
          statesRestored++;
        }
      }
      
      // Twitter ìƒíƒœ ë³µì›
      if (streamer.twitterUsername) {
        const twitterState = await this.databaseManager.getMonitorState(streamer.id, 'twitter');
        if (twitterState?.lastContentId) {
          // ë©”ëª¨ë¦¬ ìºì‹œì— ë§ˆì§€ë§‰ íŠ¸ìœ— ID ë³µì›
          this.twitterMonitor['lastTweetIds'].set(streamer.twitterUsername, twitterState.lastContentId);
          statesRestored++;
        }
      }
      
      // Cafe ìƒíƒœ ë³µì›
      if (streamer.naverCafeUserId) {
        const cafeState = await this.databaseManager.getMonitorState(streamer.id, 'cafe');
        if (cafeState?.lastContentId) {
          // ë©”ëª¨ë¦¬ ìºì‹œì— ë§ˆì§€ë§‰ ê²Œì‹œë¬¼ ID ë³µì›
          this.cafeMonitor['lastPostIds'].set(streamer.naverCafeUserId, cafeState.lastContentId);
          statesRestored++;
        }
      }
    }
    
    console.log(`âœ… Restored ${statesRestored} monitoring states for ${streamers.filter(s => s.isActive).length} active streamers`);
  } catch (error) {
    console.error('âŒ Failed to restore monitoring states:', error);
  }
}
```

### 3. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì²´í¬ ë¡œì§

#### í†µí•© ëª¨ë‹ˆí„°ë§ ì²´í¬
```typescript
private async performMonitoringCheck(): Promise<void> {
  try {
    const currentTime = Date.now();
    
    // ì ˆì „ëª¨ë“œ ê°ì§€ (ì•± ì¬ì‹œì‘ ì™„ë£Œ í›„ì—ë§Œ ê°ì§€)
    if (!this.isInitialStart && this.lastMonitoringTime > 0) {
      const timeSinceLastCheck = currentTime - this.lastMonitoringTime;
      const checkInterval = this.settingsService.getCheckInterval() * 1000;
      const dynamicThreshold = Math.max(this.sleepDetectionThreshold, checkInterval * 5);
      
      if (timeSinceLastCheck > dynamicThreshold) {
        console.log(`ğŸ’¤ Sleep mode detected: ${Math.round(timeSinceLastCheck / 1000)}s gap (threshold: ${Math.round(dynamicThreshold / 1000)}s), triggering missed notification recovery`);
        await this.recoverMissedNotifications();
      }
    }
    
    this.lastMonitoringTime = currentTime;
    
    console.log('Performing monitoring check...');
    
    // ëª¨ë“  í”Œë«í¼ ë³‘ë ¬ ëª¨ë‹ˆí„°ë§
    const [liveStatuses, tweets, cafePosts, weverseNotifications] = await Promise.all([
      this.checkChzzkStreams(),
      this.checkTwitterFeeds(),
      this.checkCafePosts(),
      this.checkWeverseNotifications()
    ]);
    
    // ë¼ì´ë¸Œ ìƒíƒœ ì—…ë°ì´íŠ¸
    await this.updateLiveStatus(liveStatuses);
    
    // ëª¨ë‹ˆí„°ë§ ìƒíƒœ ê¸°ë¡
    await this.updateMonitoringStatus();
    
    // ìœ„ë²„ìŠ¤ ì„¸ì…˜ ìƒíƒœ ì •ê¸° ê²€ì¦
    await this.checkWeverseSessionStatus();
    
    // ìœ„ë²„ìŠ¤ ì•Œë¦¼ ì „ì†¡
    await this.sendWeverseNotifications(weverseNotifications);
    
    const liveCount = liveStatuses.filter(s => s.isLive).length;
    console.log(`Monitoring check completed. CHZZK Live: ${liveCount}, Tweets: ${tweets.length}, Posts: ${cafePosts.length}, Weverse: ${weverseNotifications.length}`);
    
  } catch (error) {
    console.error('Monitoring check failed:', error);
  }
}
```

### 4. ìœ„ë²„ìŠ¤ ì„¸ì…˜ ê´€ë¦¬ ì‹œìŠ¤í…œ

#### 3ë‹¨ê³„ ìë™ ë³µêµ¬ ì‹œí€€ìŠ¤
```typescript
/**
 * ìœ„ë²„ìŠ¤ ì„¸ì…˜ 3ë‹¨ê³„ ìë™ ë³µêµ¬ ì‹œë„
 * 1ë‹¨ê³„: ì¿ í‚¤ ë³µì› â†’ 2ë‹¨ê³„: í† í° ê°±ì‹  â†’ 3ë‹¨ê³„: ì¬ë¡œê·¸ì¸
 */
private async attemptWeverseSessionRecovery(): Promise<boolean> {
  try {
    console.log('ğŸ”„ ìœ„ë²„ìŠ¤ ì„¸ì…˜ 3ë‹¨ê³„ ìë™ ë³µêµ¬ ì‹œì‘...');
    
    // 1ë‹¨ê³„: ì¿ í‚¤ ë³µì› (ì„¸ì…˜ ë¬´ê²°ì„± ê²€ì¦ ë° ì¿ í‚¤ ë°±ì—…/ë³µì›)
    console.log('ğŸ“¦ 1ë‹¨ê³„: ì¿ í‚¤ ë³µì› ì‹œë„...');
    const cookieRestored = await this.performCookieRecovery();
    if (cookieRestored) {
      console.log('âœ… 1ë‹¨ê³„ ì„±ê³µ: ì¿ í‚¤ ë³µì› ì™„ë£Œ');
      
      const step1Check = await this.weverseMonitor.checkLoginStatus();
      if (step1Check) {
        console.log('âœ… 1ë‹¨ê³„ ë³µêµ¬ë¡œ ì„¸ì…˜ ì™„ì „ ë³µêµ¬');
        await this.settingsService.updateSetting('needWeverseLogin', false);
        return true;
      }
    }
    
    // 2ë‹¨ê³„: í† í° ê°±ì‹  (ì„ ì œì  í† í° ê°±ì‹  ë° ì„¸ì…˜ ê°•í™”)
    console.log('ğŸ”„ 2ë‹¨ê³„: í† í° ê°±ì‹  ì‹œë„...');
    const tokenRefreshed = await this.performTokenRecovery();
    if (tokenRefreshed) {
      console.log('âœ… 2ë‹¨ê³„ ì„±ê³µ: í† í° ê°±ì‹  ì™„ë£Œ');
      
      const step2Check = await this.weverseMonitor.checkLoginStatus();
      if (step2Check) {
        console.log('âœ… 2ë‹¨ê³„ ë³µêµ¬ë¡œ ì„¸ì…˜ ì™„ì „ ë³µêµ¬');
        await this.settingsService.updateSetting('needWeverseLogin', false);
        return true;
      }
    }
    
    // 3ë‹¨ê³„: ì¬ë¡œê·¸ì¸ (ìë™ ë¡œê·¸ì¸ ì‹œë„)
    console.log('ğŸ”‘ 3ë‹¨ê³„: ìë™ ì¬ë¡œê·¸ì¸ ì‹œë„...');
    const reloginSuccess = await this.performReloginRecovery();
    if (reloginSuccess) {
      console.log('âœ… 3ë‹¨ê³„ ì„±ê³µ: ìë™ ì¬ë¡œê·¸ì¸ ì™„ë£Œ');
      await this.settingsService.updateSetting('needWeverseLogin', false);
      return true;
    }
    
    console.log('âŒ 3ë‹¨ê³„ ë³µêµ¬ ì‹œí€€ìŠ¤ ëª¨ë‘ ì‹¤íŒ¨ - ì‚¬ìš©ì ìˆ˜ë™ ë¡œê·¸ì¸ í•„ìš”');
    await this.settingsService.updateSetting('needWeverseLogin', true);
    return false;
    
  } catch (error) {
    console.error('âŒ ìœ„ë²„ìŠ¤ ì„¸ì…˜ ë³µêµ¬ ì¤‘ ì˜¤ë¥˜:', error);
    await this.settingsService.updateSetting('needWeverseLogin', true);
    return false;
  }
}
```

### 5. ì‹¤ì‹œê°„ UI ì—…ë°ì´íŠ¸ ì‹œìŠ¤í…œ

#### WebContentsë¥¼ í†µí•œ ì‹¤ì‹œê°„ ë™ê¸°í™”
```typescript
private async updateLiveStatus(liveStatuses: LiveStatus[]): Promise<void> {
  try {
    // ë¼ì´ë¸Œ ìƒíƒœë¥¼ íŒŒì¼ë¡œë„ ì €ì¥ (UI ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ìš©)
    const fs = require('fs').promises;
    const path = require('path');
    const { app, webContents } = require('electron');
    
    const userDataPath = app.getPath('userData');
    const liveStatusFile = path.join(userDataPath, 'live_status.json');
    
    await fs.writeFile(liveStatusFile, JSON.stringify(liveStatuses, null, 2));
    
    // ì›¹ ì¸í„°í˜ì´ìŠ¤ì— ì‹¤ì‹œê°„ ë¼ì´ë¸Œ ìƒíƒœ ë³€ê²½ ì•Œë¦¼
    const allWebContents = webContents.getAllWebContents();
    allWebContents.forEach((wc: any) => {
      if (!wc.isDestroyed()) {
        wc.send('live-status-updated', liveStatuses);
      }
    });
    
    console.log(`ğŸ“¡ Live status updated: ${liveStatuses.filter(s => s.isLive).length} live streamers`);
  } catch (error) {
    console.error('Failed to update live status file:', error);
  }
}

private notifyLoginStatusChange(needLogin: boolean): void {
  try {
    console.log(`ğŸ“¢ Broadcasting login status: needLogin=${needLogin}`);
    
    const { webContents } = require('electron');
    const allWebContents = webContents.getAllWebContents();
    allWebContents.forEach((wc: any) => {
      if (!wc.isDestroyed()) {
        // ë„¤ì´ë²„ ë¡œê·¸ì¸ ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸
        wc.send('naver-login-status-changed', { needLogin });
        
        // ì„¤ì • ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ë„ í•¨ê»˜ ë°œì†¡
        this.sendSettingsUpdateEvent(needLogin, wc);
      }
    });
    
    // íŠ¸ë ˆì´ ë©”ë‰´ ì§ì ‘ ì—…ë°ì´íŠ¸
    this.updateTrayMenuDirectly(needLogin);
    
  } catch (error) {
    console.error('Failed to notify login status change:', error);
  }
}
```

---

## ğŸ› ï¸ ì‹¤ìŠµ ì˜ˆì œ

### 1. ì´ë²¤íŠ¸ ê¸°ë°˜ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ êµ¬í˜„

#### Step 1: ì´ë²¤íŠ¸ ì—ë¯¸í„° ê¸°ë°˜ ëª¨ë‹ˆí„° í´ë˜ìŠ¤
```typescript
// src/main/services/BaseMonitor.ts
import { EventEmitter } from 'events';

abstract class BaseMonitor extends EventEmitter {
  protected isRunning: boolean = false;
  protected checkInterval: number = 30000; // 30ì´ˆ
  protected intervalId: NodeJS.Timeout | null = null;
  
  async start(): Promise<void> {
    if (this.isRunning) return;
    
    this.isRunning = true;
    console.log(`Starting ${this.constructor.name}...`);
    
    // ì¦‰ì‹œ ì²« ë²ˆì§¸ ì²´í¬ ì‹¤í–‰
    await this.performCheck();
    
    // ì£¼ê¸°ì  ì²´í¬ ìŠ¤ì¼€ì¤„ë§
    this.scheduleNextCheck();
  }
  
  async stop(): Promise<void> {
    this.isRunning = false;
    
    if (this.intervalId) {
      clearTimeout(this.intervalId);
      this.intervalId = null;
    }
    
    console.log(`Stopped ${this.constructor.name}`);
  }
  
  private scheduleNextCheck(): void {
    if (!this.isRunning) return;
    
    this.intervalId = setTimeout(async () => {
      try {
        await this.performCheck();
      } catch (error) {
        console.error(`Check failed in ${this.constructor.name}:`, error);
        this.emit('error', error);
      }
      
      this.scheduleNextCheck();
    }, this.checkInterval);
  }
  
  abstract performCheck(): Promise<void>;
}

// êµ¬ì²´ì ì¸ ëª¨ë‹ˆí„° êµ¬í˜„
class SimpleStreamMonitor extends BaseMonitor {
  private previousStatus = new Map<string, boolean>();
  
  async performCheck(): Promise<void> {
    const streamers = await this.getStreamers();
    
    for (const streamer of streamers) {
      const isLive = await this.checkStreamStatus(streamer.id);
      const wasLive = this.previousStatus.get(streamer.id) || false;
      
      if (isLive !== wasLive) {
        this.previousStatus.set(streamer.id, isLive);
        
        // ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
        this.emit('status-changed', {
          streamerId: streamer.id,
          streamerName: streamer.name,
          isLive,
          wasLive,
          timestamp: new Date()
        });
      }
    }
  }
  
  private async getStreamers(): Promise<Array<{id: string, name: string}>> {
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
    return [
      { id: 'streamer1', name: 'Test Streamer 1' },
      { id: 'streamer2', name: 'Test Streamer 2' }
    ];
  }
  
  private async checkStreamStatus(streamerId: string): Promise<boolean> {
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” API í˜¸ì¶œ ë˜ëŠ” ìŠ¤í¬ë˜í•‘
    return Math.random() > 0.7; // 30% í™•ë¥ ë¡œ ë¼ì´ë¸Œ
  }
}
```

#### Step 2: í†µí•© ëª¨ë‹ˆí„°ë§ ë§¤ë‹ˆì €
```typescript
// src/main/services/EventDrivenMonitoringManager.ts
class EventDrivenMonitoringManager extends EventEmitter {
  private monitors: Map<string, BaseMonitor> = new Map();
  private notificationService: any; // NotificationService íƒ€ì…
  
  constructor(notificationService: any) {
    super();
    this.notificationService = notificationService;
  }
  
  addMonitor(name: string, monitor: BaseMonitor): void {
    this.monitors.set(name, monitor);
    
    // ëª¨ë‹ˆí„°ì˜ ì´ë²¤íŠ¸ë¥¼ ì¤‘ì•™ì—ì„œ ì²˜ë¦¬
    monitor.on('status-changed', (data) => {
      this.handleStatusChange(name, data);
    });
    
    monitor.on('error', (error) => {
      this.handleMonitorError(name, error);
    });
  }
  
  async startAll(): Promise<void> {
    console.log(`Starting ${this.monitors.size} monitors...`);
    
    const startPromises = Array.from(this.monitors.values()).map(monitor => 
      monitor.start().catch(error => {
        console.error('Failed to start monitor:', error);
      })
    );
    
    await Promise.all(startPromises);
    console.log('All monitors started');
  }
  
  async stopAll(): Promise<void> {
    console.log('Stopping all monitors...');
    
    const stopPromises = Array.from(this.monitors.values()).map(monitor => 
      monitor.stop()
    );
    
    await Promise.all(stopPromises);
    console.log('All monitors stopped');
  }
  
  private async handleStatusChange(monitorName: string, data: any): Promise<void> {
    console.log(`Status change from ${monitorName}:`, data);
    
    // í†µí•© ì´ë²¤íŠ¸ ë°œìƒ
    this.emit('global-status-change', {
      monitor: monitorName,
      ...data
    });
    
    // ì•Œë¦¼ ì „ì†¡
    if (data.isLive && !data.wasLive) {
      await this.notificationService.sendLiveNotification(data.streamerId);
    }
  }
  
  private handleMonitorError(monitorName: string, error: Error): void {
    console.error(`Error in ${monitorName}:`, error);
    
    this.emit('monitor-error', {
      monitor: monitorName,
      error: error.message,
      timestamp: new Date()
    });
  }
}

// ì‚¬ìš© ì˜ˆì œ
const manager = new EventDrivenMonitoringManager(notificationService);

// ëª¨ë‹ˆí„° ì¶”ê°€
manager.addMonitor('stream', new SimpleStreamMonitor());
manager.addMonitor('twitter', new TwitterMonitor());

// ì „ì—­ ì´ë²¤íŠ¸ ì²˜ë¦¬
manager.on('global-status-change', (data) => {
  console.log('Global status change:', data);
});

// ì‹œì‘
await manager.startAll();
```

### 2. ì ˆì „ëª¨ë“œ ê°ì§€ì™€ ë³µêµ¬ ì‹œìŠ¤í…œ

#### Step 1: ì ˆì „ëª¨ë“œ ê°ì§€ê¸°
```typescript
// src/main/services/SleepDetector.ts
class SleepDetector extends EventEmitter {
  private lastHeartbeat: number = Date.now();
  private heartbeatInterval: NodeJS.Timeout | null = null;
  private readonly SLEEP_THRESHOLD_MS = 10 * 60 * 1000; // 10ë¶„
  private readonly HEARTBEAT_INTERVAL_MS = 30 * 1000;   // 30ì´ˆ
  
  start(): void {
    this.lastHeartbeat = Date.now();
    
    this.heartbeatInterval = setInterval(() => {
      this.checkForSleep();
    }, this.HEARTBEAT_INTERVAL_MS);
    
    console.log('Sleep detector started');
  }
  
  stop(): void {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
    console.log('Sleep detector stopped');
  }
  
  private checkForSleep(): void {
    const now = Date.now();
    const timeSinceLastHeartbeat = now - this.lastHeartbeat;
    
    if (timeSinceLastHeartbeat > this.SLEEP_THRESHOLD_MS) {
      const sleepDurationSeconds = Math.round(timeSinceLastHeartbeat / 1000);
      
      console.log(`ğŸ’¤ Sleep detected: ${sleepDurationSeconds}s gap`);
      
      this.emit('sleep-detected', {
        sleepDuration: timeSinceLastHeartbeat,
        sleepDurationSeconds,
        lastHeartbeat: new Date(this.lastHeartbeat),
        wakeUpTime: new Date(now)
      });
    }
    
    this.lastHeartbeat = now;
  }
}

// ë³µêµ¬ ë§¤ë‹ˆì €
class SleepRecoveryManager {
  constructor(
    private monitoringService: any,
    private browserPoolManager: any,
    private sessionManager: any
  ) {}
  
  async handleSleepRecovery(sleepData: any): Promise<void> {
    console.log('ğŸ”„ Starting sleep recovery process...');
    
    try {
      // 1. ì„¸ì…˜ ìƒíƒœ ê²€ì¦
      await this.validateSessions();
      
      // 2. ë¸Œë¼ìš°ì € í’€ ìƒíƒœ í™•ì¸
      await this.validateBrowserPool();
      
      // 3. ëˆ„ë½ëœ ë°ì´í„° ë³µêµ¬
      await this.recoverMissedData(sleepData.sleepDuration);
      
      // 4. ëª¨ë‹ˆí„°ë§ ì¬ì‹œì‘
      await this.restartMonitoring();
      
      console.log('âœ… Sleep recovery completed successfully');
      
    } catch (error) {
      console.error('âŒ Sleep recovery failed:', error);
      throw error;
    }
  }
  
  private async validateSessions(): Promise<void> {
    console.log('ğŸ” Validating sessions...');
    
    // ê° í”Œë«í¼ì˜ ì„¸ì…˜ ìƒíƒœ í™•ì¸
    const validationResults = await Promise.allSettled([
      this.sessionManager.validateSession('weverse'),
      this.sessionManager.validateSession('naver'),
      this.sessionManager.validateSession('twitter')
    ]);
    
    validationResults.forEach((result, index) => {
      const platforms = ['weverse', 'naver', 'twitter'];
      if (result.status === 'rejected') {
        console.warn(`âš ï¸ Session validation failed for ${platforms[index]}:`, result.reason);
      }
    });
  }
  
  private async validateBrowserPool(): Promise<void> {
    console.log('ğŸ” Validating browser pool...');
    
    // ë¸Œë¼ìš°ì € ì¸ìŠ¤í„´ìŠ¤ ìƒíƒœ í™•ì¸
    const poolStatus = this.browserPoolManager.getPoolStatus();
    console.log('Browser pool status:', poolStatus);
    
    // í•„ìš”ì‹œ í’€ ì¬ì¡°ì •
    await this.browserPoolManager.adjustBrowserPools();
  }
  
  private async recoverMissedData(sleepDuration: number): Promise<void> {
    console.log(`ğŸ”„ Recovering data for ${Math.round(sleepDuration / 1000)}s sleep period...`);
    
    // ì ˆì „ ì‹œê°„ì´ ê¸¸ìˆ˜ë¡ ë” ê´‘ë²”ìœ„í•œ ë³µêµ¬ ìˆ˜í–‰
    const recoveryScope = this.calculateRecoveryScope(sleepDuration);
    
    await this.monitoringService.recoverMissedNotifications(recoveryScope);
  }
  
  private calculateRecoveryScope(sleepDuration: number): 'light' | 'moderate' | 'full' {
    const minutes = sleepDuration / (60 * 1000);
    
    if (minutes < 30) return 'light';
    if (minutes < 120) return 'moderate';
    return 'full';
  }
  
  private async restartMonitoring(): Promise<void> {
    console.log('ğŸ”„ Restarting monitoring services...');
    
    // ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤ ì¬ì‹œì‘
    await this.monitoringService.performMonitoringCheck();
  }
}
```

#### Step 2: í†µí•© ì‚¬ìš© ì˜ˆì œ
```typescript
// src/main/main.ts
class Application {
  private sleepDetector: SleepDetector;
  private sleepRecoveryManager: SleepRecoveryManager;
  private monitoringManager: EventDrivenMonitoringManager;
  
  async initialize(): Promise<void> {
    // ì ˆì „ëª¨ë“œ ê°ì§€ê¸° ì„¤ì •
    this.sleepDetector = new SleepDetector();
    this.sleepRecoveryManager = new SleepRecoveryManager(
      this.monitoringService,
      this.browserPoolManager,
      this.sessionManager
    );
    
    // ì ˆì „ëª¨ë“œ ê°ì§€ ì‹œ ë³µêµ¬ ì‹¤í–‰
    this.sleepDetector.on('sleep-detected', async (sleepData) => {
      try {
        await this.sleepRecoveryManager.handleSleepRecovery(sleepData);
      } catch (error) {
        console.error('Sleep recovery failed:', error);
      }
    });
    
    // ì‹œì‘
    this.sleepDetector.start();
    await this.monitoringManager.startAll();
  }
  
  async shutdown(): Promise<void> {
    this.sleepDetector.stop();
    await this.monitoringManager.stopAll();
  }
}
```

### 3. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ê³¼ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

#### Step 1: ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°
```typescript
// src/main/services/PerformanceMetrics.ts
interface MetricData {
  timestamp: number;
  value: number;
  labels?: Record<string, string>;
}

class PerformanceMetrics {
  private metrics = new Map<string, MetricData[]>();
  private readonly MAX_SAMPLES = 1000; // ìµœëŒ€ ìƒ˜í”Œ ìˆ˜
  
  record(metricName: string, value: number, labels?: Record<string, string>): void {
    if (!this.metrics.has(metricName)) {
      this.metrics.set(metricName, []);
    }
    
    const samples = this.metrics.get(metricName)!;
    samples.push({
      timestamp: Date.now(),
      value,
      labels
    });
    
    // ì˜¤ë˜ëœ ìƒ˜í”Œ ì •ë¦¬
    if (samples.length > this.MAX_SAMPLES) {
      samples.splice(0, samples.length - this.MAX_SAMPLES);
    }
  }
  
  getAverage(metricName: string, timeWindowMs: number = 5 * 60 * 1000): number {
    const samples = this.metrics.get(metricName);
    if (!samples || samples.length === 0) return 0;
    
    const cutoff = Date.now() - timeWindowMs;
    const recentSamples = samples.filter(s => s.timestamp > cutoff);
    
    if (recentSamples.length === 0) return 0;
    
    const sum = recentSamples.reduce((acc, s) => acc + s.value, 0);
    return sum / recentSamples.length;
  }
  
  getPercentile(metricName: string, percentile: number, timeWindowMs: number = 5 * 60 * 1000): number {
    const samples = this.metrics.get(metricName);
    if (!samples || samples.length === 0) return 0;
    
    const cutoff = Date.now() - timeWindowMs;
    const recentSamples = samples
      .filter(s => s.timestamp > cutoff)
      .map(s => s.value)
      .sort((a, b) => a - b);
    
    if (recentSamples.length === 0) return 0;
    
    const index = Math.ceil((percentile / 100) * recentSamples.length) - 1;
    return recentSamples[Math.max(0, index)];
  }
  
  getSummary(metricName: string): any {
    const samples = this.metrics.get(metricName);
    if (!samples || samples.length === 0) {
      return { count: 0, average: 0, p95: 0, p99: 0 };
    }
    
    return {
      count: samples.length,
      average: this.getAverage(metricName),
      p95: this.getPercentile(metricName, 95),
      p99: this.getPercentile(metricName, 99),
      latest: samples[samples.length - 1]?.value || 0
    };
  }
}

// ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ì´ í¬í•¨ëœ ëª¨ë‹ˆí„° í´ë˜ìŠ¤
class PerformanceAwareMonitor extends BaseMonitor {
  private metrics: PerformanceMetrics;
  
  constructor() {
    super();
    this.metrics = new PerformanceMetrics();
  }
  
  async performCheck(): Promise<void> {
    const startTime = performance.now();
    
    try {
      // ì‹¤ì œ ì²´í¬ ë¡œì§
      await this.actualCheck();
      
      // ì„±ê³µ ë©”íŠ¸ë¦­ ê¸°ë¡
      const duration = performance.now() - startTime;
      this.metrics.record('check_duration_ms', duration, { status: 'success' });
      this.metrics.record('check_count', 1, { status: 'success' });
      
    } catch (error) {
      // ì‹¤íŒ¨ ë©”íŠ¸ë¦­ ê¸°ë¡
      const duration = performance.now() - startTime;
      this.metrics.record('check_duration_ms', duration, { status: 'error' });
      this.metrics.record('check_count', 1, { status: 'error' });
      this.metrics.record('error_count', 1);
      
      throw error;
    }
  }
  
  private async actualCheck(): Promise<void> {
    // ì‹¤ì œ ëª¨ë‹ˆí„°ë§ ë¡œì§
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000));
    
    // 10% í™•ë¥ ë¡œ ì—ëŸ¬ ë°œìƒ (í…ŒìŠ¤íŠ¸ìš©)
    if (Math.random() < 0.1) {
      throw new Error('Random test error');
    }
  }
  
  getPerformanceReport(): any {
    return {
      checkDuration: this.metrics.getSummary('check_duration_ms'),
      successCount: this.metrics.getSummary('check_count'),
      errorCount: this.metrics.getSummary('error_count')
    };
  }
}
```

---

## ğŸ“‹ ê³¼ì œ

### ğŸ“ ê¸°ë³¸ ê³¼ì œ
1. **ì´ë²¤íŠ¸ ê¸°ë°˜ ëª¨ë‹ˆí„°**: EventEmitterë¥¼ ìƒì†ë°›ì€ ëª¨ë‹ˆí„°ë§ í´ë˜ìŠ¤ êµ¬í˜„
2. **ì ˆì „ëª¨ë“œ ê°ì§€**: ì‹œê°„ ê°„ê²©ì„ ë¶„ì„í•˜ì—¬ ì ˆì „ëª¨ë“œë¥¼ ê°ì§€í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„
3. **ìƒíƒœ ë³µì›**: ì•± ì¬ì‹œì‘ ì‹œ ì´ì „ ìƒíƒœë¥¼ ë³µì›í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„

### ğŸš€ ì‘ìš© ê³¼ì œ
1. **ì„±ëŠ¥ ë©”íŠ¸ë¦­**: ëª¨ë‹ˆí„°ë§ ì„±ëŠ¥ì„ ì¸¡ì •í•˜ê³  ë¶„ì„í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„
2. **ìë™ ë³µêµ¬**: ì—ëŸ¬ ë°œìƒ ì‹œ ìë™ìœ¼ë¡œ ë³µêµ¬í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„
3. **ë¶€í•˜ ë¶„ì‚°**: ì—¬ëŸ¬ ëª¨ë‹ˆí„° ê°„ ì‘ì—…ì„ íš¨ìœ¨ì ìœ¼ë¡œ ë¶„ì‚°í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„

### ğŸ’ª ë„ì „ ê³¼ì œ
1. **ì§€ëŠ¥í˜• ìŠ¤ì¼€ì¤„ë§**: ì‚¬ìš© íŒ¨í„´ì„ í•™ìŠµí•˜ì—¬ ìµœì ì˜ ì²´í¬ ê°„ê²©ì„ ê²°ì •í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„
2. **ë¶„ì‚° ëª¨ë‹ˆí„°ë§**: ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ ë˜ëŠ” ì„œë²„ì—ì„œ í˜‘ì—…í•˜ëŠ” ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ êµ¬í˜„
3. **ì˜ˆì¸¡ ë¶„ì„**: ê³¼ê±° ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ë¯¸ë˜ ìƒíƒœë¥¼ ì˜ˆì¸¡í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„

---

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

### ğŸ“– í•µì‹¬ ë¬¸ì„œ
- [Node.js EventEmitter](https://nodejs.org/api/events.html)
- [Event-Driven Architecture Patterns](https://martinfowler.com/articles/201701-event-driven.html)
- [Performance Monitoring Best Practices](https://nodejs.org/en/docs/guides/simple-profiling)

### ğŸ› ï¸ ì‹¤ìŠµ ë¦¬ì†ŒìŠ¤
- [Node.js Performance Hooks](https://nodejs.org/api/perf_hooks.html)
- [Memory Management in Node.js](https://nodejs.org/en/docs/guides/simple-profiling)
- [Real-time System Design](https://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)

### ğŸ¯ í™•ì¥ í•™ìŠµ
- **ë¶„ì‚° ì‹œìŠ¤í…œ**: Redis Pub/Subë¥¼ í™œìš©í•œ ë¶„ì‚° ì´ë²¤íŠ¸ ì²˜ë¦¬
- **ìŠ¤íŠ¸ë¦¬ë° ë°ì´í„°**: Apache Kafkaë¥¼ í™œìš©í•œ ëŒ€ìš©ëŸ‰ ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬
- **ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ**: Grafanaë¥¼ í™œìš©í•œ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ êµ¬ì¶•

---

## ğŸ’¡ í•µì‹¬ ì •ë¦¬

### âœ… í•™ìŠµ ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ì˜ ì¥ì ê³¼ êµ¬í˜„ ë°©ë²• ì´í•´
- [ ] ì‹¤ì‹œê°„ ìƒíƒœ ê´€ë¦¬ì™€ ì§€ì†ì„± ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„
- [ ] ì ˆì „ëª¨ë“œ ê°ì§€ì™€ ìë™ ë³µêµ¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ê³¼ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ëŒ€ìš©ëŸ‰ ì‹¤ì‹œê°„ ì²˜ë¦¬ë¥¼ ìœ„í•œ ìµœì í™” ê¸°ë²• ìŠµë“

### ğŸ¯ ë‹¤ìŒ ë‹¨ê³„ ë¯¸ë¦¬ë³´ê¸°
**13ì¼ì°¨**ì—ì„œëŠ” ì´ëŸ¬í•œ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì˜ **ì„¤ì • ê´€ë¦¬ì™€ ìë™ ì‹œì‘** ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ì—¬, ì‚¬ìš©ì ì¹œí™”ì ì´ê³  ìš´ì˜í•˜ê¸° ì‰¬ìš´ ì‹œìŠ¤í…œì„ ì™„ì„±í•©ë‹ˆë‹¤.

---

*ğŸš€ ëŒ€ìš©ëŸ‰ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì˜ í•µì‹¬ ì•„í‚¤í…ì²˜ì™€ ì„±ëŠ¥ ìµœì í™” ê¸°ë²•ì„ ì™„ì „íˆ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤! ì´ì œ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ì‹¤ì‹œê°„ ì‹œìŠ¤í…œì„ ì„¤ê³„í•˜ê³  êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.*