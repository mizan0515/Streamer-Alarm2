# 9ì¼ì°¨: ë°ì´í„°ë² ì´ìŠ¤ í†µí•©ê³¼ ë§ˆì´ê·¸ë ˆì´ì…˜

## ğŸ“š í•™ìŠµ ëª©í‘œ
- SQLiteì™€ better-sqlite3ë¥¼ í™œìš©í•œ ë°ì´í„° ì˜ì†ì„± êµ¬í˜„
- ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„ì™€ ì •ê·œí™” ì›ì¹™ ì ìš©
- ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œìŠ¤í…œì„ í†µí•œ ì•ˆì „í•œ ìŠ¤í‚¤ë§ˆ ë³€ê²½
- íŠ¸ëœì­ì…˜ê³¼ ì„±ëŠ¥ ìµœì í™” ê¸°ë²• ìŠµë“

## ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ì•„í‚¤í…ì²˜ ê°œìš”

### Streamer Alarm 2ì˜ ë°ì´í„° ëª¨ë¸
ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œ ì‚¬ìš©ë˜ëŠ” ë³µí•©ì ì¸ ë°ì´í„° êµ¬ì¡°ë¥¼ ë¶„ì„í•´ë³´ê² ìŠµë‹ˆë‹¤.

```sql
-- í•µì‹¬ ì—”í‹°í‹° ê´€ê³„ë„
Streamers (1) â†â†’ (N) NotificationSettings
Streamers (1) â†â†’ (N) MonitorStates  
Streamers (1) â†â†’ (N) Notifications
WeverseArtists (1) â†â†’ (N) Notifications
```

### ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ ì›ì¹™
1. **ì •ê·œí™”**: ë°ì´í„° ì¤‘ë³µ ìµœì†Œí™”ì™€ ì¼ê´€ì„± ë³´ì¥
2. **ì¸ë±ì‹±**: ì¿¼ë¦¬ ì„±ëŠ¥ ìµœì í™”
3. **ì œì•½ì¡°ê±´**: ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥
4. **íŠ¸ë¦¬ê±°**: ìë™í™”ëœ ë°ì´í„° ê´€ë¦¬

## ğŸ—ï¸ DatabaseManager êµ¬ì¡° ë¶„ì„

### í•µì‹¬ í´ë˜ìŠ¤ êµ¬ì¡°
```typescript
export class DatabaseManager {
  private db!: Database.Database;
  private dbPath: string;
  private readonly CURRENT_SCHEMA_VERSION = 4;

  constructor() {
    const userDataPath = app.getPath('userData');
    this.dbPath = path.join(userDataPath, 'streamer_alarm.db');
  }

  // ì´ˆê¸°í™” ë° ë§ˆì´ê·¸ë ˆì´ì…˜
  async initialize(): Promise<void>
  
  // ìŠ¤í‚¤ë§ˆ ê´€ë¦¬
  private createTables(): void
  private performMigration(): void
  private migrateToVersion2/3/4(): void
  
  // CRUD ì‘ì—…
  async getStreamers(): Promise<StreamerData[]>
  async addStreamer(data: StreamerData): Promise<StreamerData>
  async updateStreamer(data: StreamerData): Promise<StreamerData>
  async deleteStreamer(id: number): Promise<boolean>
  
  // ê³ ê¸‰ ì¿¼ë¦¬
  async getStreamersWithSettings(): Promise<any[]>
  async bulkUpdateMonitorStates(): Promise<void>
  
  // íŠ¸ëœì­ì…˜ ê´€ë¦¬
  private createTransaction(): Transaction
}
```

### ì‹¤ì œ ì´ˆê¸°í™” í”„ë¡œì„¸ìŠ¤ ë¶„ì„
```typescript
async initialize(): Promise<void> {
  try {
    this.logInfo('Starting database initialization...');
    this.logInfo(`Database path: ${this.dbPath}`);
    
    // 1. ì‚¬ìš©ì ë°ì´í„° ë””ë ‰í† ë¦¬ ë³´ì¥
    await this.ensureUserDataDirectory();
    
    // 2. ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
    this.db = new Database(this.dbPath);
    
    // 3. ì„±ëŠ¥ ìµœì í™” ì„¤ì •
    this.db.pragma('journal_mode = WAL');  // Write-Ahead Logging
    this.db.pragma('foreign_keys = ON');   // ì™¸ë˜ í‚¤ ì œì•½ í™œì„±í™”
    
    // 4. ê¸°ë³¸ í…Œì´ë¸” ìƒì„±
    this.createTables();
    
    // 5. ìŠ¤í‚¤ë§ˆ ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    this.initializeSchemaVersion();
    
    // 6. ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰
    this.performMigration();
    
    // 7. ê¸°ë³¸ ë°ì´í„° ì‚½ì…
    this.insertDefaultData();
    
    // 8. íŠ¹ìˆ˜ ë§ˆì´ê·¸ë ˆì´ì…˜ (Weverse ë“±)
    await this.migrateWeverseNotifications();
    
    this.logSuccess('Database initialization completed successfully');
  } catch (error) {
    this.logError('Database initialization failed', error);
    throw error;
  }
}
```

## ğŸ“‹ ìŠ¤í‚¤ë§ˆ ì„¤ê³„ì™€ í…Œì´ë¸” êµ¬ì¡°

### 1. í•µì‹¬ ì—”í‹°í‹° í…Œì´ë¸”
```sql
-- ìŠ¤íŠ¸ë¦¬ë¨¸ ì •ë³´ í…Œì´ë¸”
CREATE TABLE streamers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT UNIQUE NOT NULL,                    -- ìŠ¤íŠ¸ë¦¬ë¨¸ ì´ë¦„ (ê³ ìœ )
  chzzk_id TEXT,                               -- ì¹˜ì§€ì§ ì±„ë„ ID
  twitter_username TEXT,                       -- íŠ¸ìœ„í„° ì‚¬ìš©ìëª…
  naver_cafe_user_id TEXT,                     -- ë„¤ì´ë²„ ì¹´í˜ ì‚¬ìš©ì ID
  cafe_club_id TEXT DEFAULT '30919539',        -- ì¹´í˜ í´ëŸ½ ID
  profile_image_url TEXT,                      -- í”„ë¡œí•„ ì´ë¯¸ì§€ URL
  is_active BOOLEAN DEFAULT 1,                 -- í™œì„± ìƒíƒœ
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ìœ„ë²„ìŠ¤ ì•„í‹°ìŠ¤íŠ¸ í…Œì´ë¸” (ë…ë¦½ì ì¸ ì—”í‹°í‹°)
CREATE TABLE weverse_artists (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  artist_name TEXT UNIQUE NOT NULL,            -- ì•„í‹°ìŠ¤íŠ¸ ì´ë¦„
  profile_image_url TEXT,                      -- í”„ë¡œí•„ ì´ë¯¸ì§€
  is_enabled BOOLEAN DEFAULT 1,               -- í™œì„± ìƒíƒœ
  last_notification_id TEXT,                  -- ë§ˆì§€ë§‰ ì•Œë¦¼ ID (ì¤‘ë³µ ë°©ì§€)
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 2. ì„¤ì • ë° ìƒíƒœ ê´€ë¦¬ í…Œì´ë¸”
```sql
-- í”Œë«í¼ë³„ ì•Œë¦¼ ì„¤ì •
CREATE TABLE notification_settings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  streamer_id INTEGER NOT NULL,
  platform TEXT NOT NULL CHECK (platform IN ('chzzk', 'cafe', 'twitter', 'weverse')),
  enabled BOOLEAN DEFAULT 1,
  FOREIGN KEY (streamer_id) REFERENCES streamers(id) ON DELETE CASCADE,
  UNIQUE(streamer_id, platform)  -- ìŠ¤íŠ¸ë¦¬ë¨¸-í”Œë«í¼ ì¡°í•©ì˜ ê³ ìœ ì„±
);

-- ëª¨ë‹ˆí„°ë§ ìƒíƒœ ì¶”ì 
CREATE TABLE monitor_states (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  streamer_id INTEGER NOT NULL,
  platform TEXT NOT NULL CHECK (platform IN ('chzzk', 'cafe', 'twitter', 'weverse')),
  last_content_id TEXT,                        -- ë§ˆì§€ë§‰ í™•ì¸ëœ ì»¨í…ì¸  ID
  last_check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_status TEXT,                           -- ë§ˆì§€ë§‰ ìƒíƒœ (live, offline ë“±)
  FOREIGN KEY (streamer_id) REFERENCES streamers(id) ON DELETE CASCADE,
  UNIQUE(streamer_id, platform)
);

-- ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì—­ ì„¤ì •
CREATE TABLE app_settings (
  key TEXT PRIMARY KEY,                        -- ì„¤ì • í‚¤
  value TEXT NOT NULL,                        -- ì„¤ì • ê°’ (JSON ë¬¸ìì—´ ê°€ëŠ¥)
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 3. ì•Œë¦¼ ê¸°ë¡ í…Œì´ë¸” (ë³µí•© ê´€ê³„)
```sql
-- í†µí•© ì•Œë¦¼ í…Œì´ë¸” (ìŠ¤íŠ¸ë¦¬ë¨¸ì™€ ìœ„ë²„ìŠ¤ ì•„í‹°ìŠ¤íŠ¸ ëª¨ë‘ ì§€ì›)
CREATE TABLE notifications (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  streamer_id INTEGER,                         -- ìŠ¤íŠ¸ë¦¬ë¨¸ ID (nullable)
  weverse_artist_id INTEGER,                   -- ìœ„ë²„ìŠ¤ ì•„í‹°ìŠ¤íŠ¸ ID (nullable)
  type TEXT NOT NULL,                         -- ì•Œë¦¼ íƒ€ì… (live, post, tweet ë“±)
  title TEXT NOT NULL,                        -- ì•Œë¦¼ ì œëª©
  content TEXT,                               -- ì•Œë¦¼ ë‚´ìš© (í…ìŠ¤íŠ¸)
  content_html TEXT,                          -- ì•Œë¦¼ ë‚´ìš© (HTML)
  url TEXT,                                   -- ê´€ë ¨ URL
  unique_key TEXT UNIQUE,                     -- ì¤‘ë³µ ë°©ì§€ìš© ê³ ìœ  í‚¤
  profile_image_url TEXT,                     -- í”„ë¡œí•„ ì´ë¯¸ì§€ (ìºì‹œ)
  is_read BOOLEAN DEFAULT 0,                  -- ì½ìŒ ìƒíƒœ
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  -- ì™¸ë˜ í‚¤ ì œì•½ (ë‘ ê°œ ì¤‘ í•˜ë‚˜ëŠ” NULLì´ì–´ì•¼ í•¨)
  FOREIGN KEY (streamer_id) REFERENCES streamers(id) ON DELETE CASCADE,
  FOREIGN KEY (weverse_artist_id) REFERENCES weverse_artists(id) ON DELETE CASCADE,
  
  -- ì²´í¬ ì œì•½: ìŠ¤íŠ¸ë¦¬ë¨¸ ë˜ëŠ” ìœ„ë²„ìŠ¤ ì•„í‹°ìŠ¤íŠ¸ ì¤‘ í•˜ë‚˜ëŠ” ë°˜ë“œì‹œ ì¡´ì¬
  CHECK ((streamer_id IS NOT NULL AND weverse_artist_id IS NULL) OR 
         (streamer_id IS NULL AND weverse_artist_id IS NOT NULL))
);
```

## ğŸ”„ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œìŠ¤í…œ êµ¬í˜„

### ìŠ¤í‚¤ë§ˆ ë²„ì „ ê´€ë¦¬
```typescript
// ìŠ¤í‚¤ë§ˆ ë²„ì „ ì¶”ì  í…Œì´ë¸”
CREATE TABLE schema_version (
  id INTEGER PRIMARY KEY CHECK (id = 1),      -- ë‹¨ì¼ í–‰ ë³´ì¥
  version INTEGER NOT NULL,                   -- í˜„ì¬ ìŠ¤í‚¤ë§ˆ ë²„ì „
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

class DatabaseManager {
  private readonly CURRENT_SCHEMA_VERSION = 4;
  
  private initializeSchemaVersion(): void {
    const versionCheck = this.db.prepare(`
      SELECT COUNT(*) as count FROM schema_version WHERE id = 1
    `).get() as { count: number };
    
    if (versionCheck.count === 0) {
      // ì´ˆê¸° ë²„ì „ ì„¤ì •
      this.db.prepare(`
        INSERT INTO schema_version (id, version) VALUES (1, 1)
      `).run();
      this.logSchema('Schema version initialized to 1');
    }
  }
  
  private performMigration(): void {
    const currentVersion = this.getCurrentSchemaVersion();
    this.logSchema(`Current schema version: ${currentVersion}`);
    this.logSchema(`Target schema version: ${this.CURRENT_SCHEMA_VERSION}`);
    
    if (currentVersion < this.CURRENT_SCHEMA_VERSION) {
      this.logSchema('Starting database migration...');
      
      // ìˆœì°¨ì  ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰
      for (let version = currentVersion + 1; version <= this.CURRENT_SCHEMA_VERSION; version++) {
        this.logSchema(`Migrating to version ${version}...`);
        
        switch (version) {
          case 2:
            this.migrateToVersion2();
            break;
          case 3:
            this.migrateToVersion3();
            break;
          case 4:
            this.migrateToVersion4();
            break;
          default:
            throw new Error(`Unknown migration version: ${version}`);
        }
        
        // ë²„ì „ ì—…ë°ì´íŠ¸
        this.updateSchemaVersion(version);
        this.logSchema(`Successfully migrated to version ${version}`);
      }
      
      this.logSuccess('Database migration completed');
    } else {
      this.logSchema('Database is up to date');
    }
  }
}
```

### ì‹¤ì œ ë§ˆì´ê·¸ë ˆì´ì…˜ êµ¬í˜„ ì˜ˆì‹œ
```typescript
private migrateToVersion3(): void {
  // íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì•ˆì „í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ ë³´ì¥
  const migration = this.db.transaction(() => {
    try {
      console.log('ğŸ“ Migration v3: Adding Weverse support');
      
      // 1. ìƒˆ í…Œì´ë¸” ìƒì„± í™•ì¸
      const tablesList = this.db.prepare("SELECT name FROM sqlite_master WHERE type='table'").all();
      const existingTables = tablesList.map((table: any) => table.name);
      
      if (!existingTables.includes('weverse_artists')) {
        this.db.exec(`
          CREATE TABLE weverse_artists (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            artist_name TEXT UNIQUE NOT NULL,
            profile_image_url TEXT,
            is_enabled BOOLEAN DEFAULT 1,
            last_notification_id TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `);
        console.log('âœ… Created weverse_artists table');
      }
      
      // 2. ê¸°ì¡´ í…Œì´ë¸”ì— ì»¬ëŸ¼ ì¶”ê°€
      const notificationTableInfo = this.db.prepare("PRAGMA table_info(notifications)").all();
      const notificationColumns = notificationTableInfo.map((col: any) => col.name);
      
      const requiredColumns = [
        { name: 'weverse_artist_id', type: 'INTEGER' },
        { name: 'profile_image_url', type: 'TEXT' },
        { name: 'is_read', type: 'BOOLEAN DEFAULT 0' },
        { name: 'content_html', type: 'TEXT' }
      ];
      
      for (const column of requiredColumns) {
        if (!notificationColumns.includes(column.name)) {
          this.db.exec(`ALTER TABLE notifications ADD COLUMN ${column.name} ${column.type}`);
          console.log(`âœ… Added ${column.name} column to notifications`);
        }
      }
      
      // 3. ì¸ë±ìŠ¤ ë° íŠ¸ë¦¬ê±° ìƒì„±
      this.createConditionalIndexes();
      this.createWeverseArtistsTriggers();
      
      // 4. ë§ˆì´ê·¸ë ˆì´ì…˜ ê²€ì¦
      this.validateVersion3Migration();
      
    } catch (error) {
      console.error('âŒ Migration v3 failed:', error);
      throw error;
    }
  });
  
  // íŠ¸ëœì­ì…˜ ì‹¤í–‰
  migration();
}

private validateVersion3Migration(): void {
  // ë§ˆì´ê·¸ë ˆì´ì…˜ ê²€ì¦ ë¡œì§
  const weverseTableExists = this.db.prepare(`
    SELECT COUNT(*) as count 
    FROM sqlite_master 
    WHERE type='table' AND name='weverse_artists'
  `).get() as { count: number };
  
  if (weverseTableExists.count === 0) {
    throw new Error('weverse_artists table was not created');
  }
  
  const notificationColumns = this.getTableColumns('notifications');
  const requiredColumns = ['weverse_artist_id', 'profile_image_url', 'is_read', 'content_html'];
  
  for (const column of requiredColumns) {
    if (!notificationColumns.includes(column)) {
      throw new Error(`Required column ${column} was not added to notifications table`);
    }
  }
  
  console.log('âœ… Migration v3 validation passed');
}
```

## ğŸš€ ì„±ëŠ¥ ìµœì í™” ê¸°ë²•

### 1. ì¸ë±ìŠ¤ ì „ëµ
```sql
-- ì¡°íšŒ ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ ì¸ë±ìŠ¤
CREATE INDEX idx_notifications_created_at ON notifications(created_at DESC);
CREATE INDEX idx_notifications_type ON notifications(type);
CREATE INDEX idx_notifications_unique_key ON notifications(unique_key);
CREATE INDEX idx_streamers_active ON streamers(is_active);
CREATE INDEX idx_monitor_states_streamer_platform ON monitor_states(streamer_id, platform);

-- ë³µí•© ì¸ë±ìŠ¤ (ë‹¤ì¤‘ ì»¬ëŸ¼ ì¿¼ë¦¬ ìµœì í™”)
CREATE INDEX idx_notifications_streamer_type ON notifications(streamer_id, type);
CREATE INDEX idx_notifications_weverse_type ON notifications(weverse_artist_id, type);

-- ì¡°ê±´ë¶€ ì¸ë±ìŠ¤ (íŠ¹ì • ì¡°ê±´ì˜ ë°ì´í„°ë§Œ ì¸ë±ì‹±)
CREATE INDEX idx_notifications_unread ON notifications(created_at) WHERE is_read = 0;
CREATE INDEX idx_active_streamers ON streamers(name) WHERE is_active = 1;
```

### 2. ì¿¼ë¦¬ ìµœì í™” íŒ¨í„´
```typescript
class DatabaseManager {
  // ì¤€ë¹„ëœ ë¬¸ì¥ ìºì‹±ìœ¼ë¡œ ì„±ëŠ¥ í–¥ìƒ
  private preparedStatements: Map<string, Database.Statement> = new Map();
  
  private getPreparedStatement(key: string, sql: string): Database.Statement {
    if (!this.preparedStatements.has(key)) {
      this.preparedStatements.set(key, this.db.prepare(sql));
    }
    return this.preparedStatements.get(key)!;
  }
  
  async getActiveStreamers(): Promise<StreamerData[]> {
    // ì¤€ë¹„ëœ ë¬¸ì¥ ì‚¬ìš©
    const stmt = this.getPreparedStatement('getActiveStreamers', `
      SELECT 
        id,
        name,
        chzzk_id as chzzkId,
        twitter_username as twitterUsername,
        profile_image_url as profileImageUrl,
        is_active as isActive,
        created_at as createdAt,
        updated_at as updatedAt
      FROM streamers 
      WHERE is_active = 1
      ORDER BY name
    `);
    
    return stmt.all() as StreamerData[];
  }
  
  async getRecentNotifications(limit: number = 50): Promise<NotificationData[]> {
    const stmt = this.getPreparedStatement('getRecentNotifications', `
      SELECT 
        n.id,
        n.type,
        n.title,
        n.content,
        n.url,
        n.is_read as isRead,
        n.created_at as createdAt,
        COALESCE(s.name, wa.artist_name) as sourceName,
        COALESCE(n.profile_image_url, s.profile_image_url, wa.profile_image_url) as profileImageUrl
      FROM notifications n
      LEFT JOIN streamers s ON n.streamer_id = s.id
      LEFT JOIN weverse_artists wa ON n.weverse_artist_id = wa.id
      ORDER BY n.created_at DESC
      LIMIT ?
    `);
    
    return stmt.all(limit) as NotificationData[];
  }
}
```

### 3. íŠ¸ëœì­ì…˜ ê´€ë¦¬
```typescript
class DatabaseManager {
  // íŠ¸ëœì­ì…˜ í—¬í¼ ë©”ì„œë“œ
  private executeInTransaction<T>(operation: () => T): T {
    const transaction = this.db.transaction(operation);
    return transaction();
  }
  
  async bulkInsertNotifications(notifications: NotificationData[]): Promise<void> {
    this.executeInTransaction(() => {
      const insertStmt = this.db.prepare(`
        INSERT INTO notifications (
          streamer_id, weverse_artist_id, type, title, content, 
          content_html, url, unique_key, profile_image_url
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);
      
      for (const notification of notifications) {
        insertStmt.run(
          notification.streamerId || null,
          notification.weverseArtistId || null,
          notification.type,
          notification.title,
          notification.content || null,
          notification.contentHtml || null,
          notification.url || null,
          notification.uniqueKey,
          notification.profileImageUrl || null
        );
      }
    });
  }
  
  async updateStreamerWithSettings(
    streamerId: number, 
    streamerData: Partial<StreamerData>,
    settingsData: NotificationSettings[]
  ): Promise<void> {
    this.executeInTransaction(() => {
      // 1. ìŠ¤íŠ¸ë¦¬ë¨¸ ì •ë³´ ì—…ë°ì´íŠ¸
      if (Object.keys(streamerData).length > 0) {
        const updateFields = Object.keys(streamerData)
          .map(key => `${this.camelToSnake(key)} = ?`)
          .join(', ');
          
        const stmt = this.db.prepare(`
          UPDATE streamers 
          SET ${updateFields}, updated_at = CURRENT_TIMESTAMP 
          WHERE id = ?
        `);
        
        const values = Object.values(streamerData);
        stmt.run(...values, streamerId);
      }
      
      // 2. ì•Œë¦¼ ì„¤ì • ì—…ë°ì´íŠ¸
      for (const setting of settingsData) {
        const upsertStmt = this.db.prepare(`
          INSERT INTO notification_settings (streamer_id, platform, enabled)
          VALUES (?, ?, ?)
          ON CONFLICT(streamer_id, platform) 
          DO UPDATE SET enabled = excluded.enabled
        `);
        
        upsertStmt.run(streamerId, setting.platform, setting.enabled);
      }
    });
  }
}
```

## ğŸ“Š ì‹¤ìŠµ: ê³ ê¸‰ ë°ì´í„°ë² ì´ìŠ¤ íŒ¨í„´ êµ¬í˜„

### ì‹¤ìŠµ 1: Repository íŒ¨í„´ êµ¬í˜„
```typescript
// src/main/repositories/BaseRepository.ts
import { Database } from 'better-sqlite3';

export abstract class BaseRepository<T> {
  protected db: Database.Database;
  protected tableName: string;
  protected preparedStatements: Map<string, Database.Statement> = new Map();

  constructor(db: Database.Database, tableName: string) {
    this.db = db;
    this.tableName = tableName;
  }

  protected getPreparedStatement(key: string, sql: string): Database.Statement {
    const fullKey = `${this.tableName}_${key}`;
    if (!this.preparedStatements.has(fullKey)) {
      this.preparedStatements.set(fullKey, this.db.prepare(sql));
    }
    return this.preparedStatements.get(fullKey)!;
  }

  abstract findById(id: number): Promise<T | null>;
  abstract findAll(): Promise<T[]>;
  abstract create(data: Omit<T, 'id'>): Promise<T>;
  abstract update(id: number, data: Partial<T>): Promise<T>;
  abstract delete(id: number): Promise<boolean>;

  // ê³µí†µ í˜ì´ì§€ë„¤ì´ì…˜
  async findWithPagination(page: number, limit: number): Promise<{ data: T[], total: number }> {
    const offset = (page - 1) * limit;
    
    const countStmt = this.getPreparedStatement('count', `SELECT COUNT(*) as count FROM ${this.tableName}`);
    const total = (countStmt.get() as { count: number }).count;
    
    const dataStmt = this.getPreparedStatement('paginate', `
      SELECT * FROM ${this.tableName} 
      ORDER BY id DESC 
      LIMIT ? OFFSET ?
    `);
    const data = dataStmt.all(limit, offset) as T[];
    
    return { data, total };
  }

  // ì¡°ê±´ë¶€ ê²€ìƒ‰
  async findWhere(conditions: Partial<T>): Promise<T[]> {
    const whereClause = Object.keys(conditions)
      .map(key => `${this.camelToSnake(key)} = ?`)
      .join(' AND ');
    
    const sql = `SELECT * FROM ${this.tableName} WHERE ${whereClause}`;
    const values = Object.values(conditions);
    
    const stmt = this.getPreparedStatement(`findWhere_${whereClause}`, sql);
    return stmt.all(...values) as T[];
  }

  protected camelToSnake(str: string): string {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
  }
  
  protected snakeToCamel(str: string): string {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
  }
}

// src/main/repositories/StreamerRepository.ts
import { BaseRepository } from './BaseRepository';
import { StreamerData } from '@shared/types';

export class StreamerRepository extends BaseRepository<StreamerData> {
  constructor(db: Database.Database) {
    super(db, 'streamers');
  }

  async findById(id: number): Promise<StreamerData | null> {
    const stmt = this.getPreparedStatement('findById', `
      SELECT 
        id,
        name,
        chzzk_id as chzzkId,
        twitter_username as twitterUsername,
        naver_cafe_user_id as naverCafeUserId,
        cafe_club_id as cafeClubId,
        profile_image_url as profileImageUrl,
        is_active as isActive,
        created_at as createdAt,
        updated_at as updatedAt
      FROM streamers 
      WHERE id = ?
    `);
    
    return (stmt.get(id) as StreamerData) || null;
  }

  async findAll(): Promise<StreamerData[]> {
    const stmt = this.getPreparedStatement('findAll', `
      SELECT 
        id,
        name,
        chzzk_id as chzzkId,
        twitter_username as twitterUsername,
        naver_cafe_user_id as naverCafeUserId,
        cafe_club_id as cafeClubId,
        profile_image_url as profileImageUrl,
        is_active as isActive,
        created_at as createdAt,
        updated_at as updatedAt
      FROM streamers 
      ORDER BY name
    `);
    
    return stmt.all() as StreamerData[];
  }

  async create(data: Omit<StreamerData, 'id'>): Promise<StreamerData> {
    const stmt = this.getPreparedStatement('create', `
      INSERT INTO streamers (
        name, chzzk_id, twitter_username, naver_cafe_user_id, 
        cafe_club_id, profile_image_url, is_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `);
    
    const result = stmt.run(
      data.name,
      data.chzzkId || null,
      data.twitterUsername || null,
      data.naverCafeUserId || null,
      data.cafeClubId || '30919539',
      data.profileImageUrl || null,
      data.isActive ? 1 : 0
    );
    
    return this.findById(result.lastInsertRowid as number) as Promise<StreamerData>;
  }

  async update(id: number, data: Partial<StreamerData>): Promise<StreamerData> {
    const updateFields = Object.keys(data)
      .filter(key => key !== 'id')
      .map(key => `${this.camelToSnake(key)} = ?`)
      .join(', ');
    
    const stmt = this.getPreparedStatement(`update_${updateFields.replace(/[^a-zA-Z0-9_]/g, '_')}`, `
      UPDATE streamers 
      SET ${updateFields}, updated_at = CURRENT_TIMESTAMP 
      WHERE id = ?
    `);
    
    const values = Object.entries(data)
      .filter(([key]) => key !== 'id')
      .map(([, value]) => value);
    
    stmt.run(...values, id);
    
    return this.findById(id) as Promise<StreamerData>;
  }

  async delete(id: number): Promise<boolean> {
    const stmt = this.getPreparedStatement('delete', 'DELETE FROM streamers WHERE id = ?');
    const result = stmt.run(id);
    return result.changes > 0;
  }

  // ìŠ¤íŠ¸ë¦¬ë¨¸ íŠ¹í™” ë©”ì„œë“œë“¤
  async findActive(): Promise<StreamerData[]> {
    const stmt = this.getPreparedStatement('findActive', `
      SELECT 
        id,
        name,
        chzzk_id as chzzkId,
        twitter_username as twitterUsername,
        naver_cafe_user_id as naverCafeUserId,
        cafe_club_id as cafeClubId,
        profile_image_url as profileImageUrl,
        is_active as isActive,
        created_at as createdAt,
        updated_at as updatedAt
      FROM streamers 
      WHERE is_active = 1
      ORDER BY name
    `);
    
    return stmt.all() as StreamerData[];
  }

  async findByChzzkId(chzzkId: string): Promise<StreamerData | null> {
    const stmt = this.getPreparedStatement('findByChzzkId', `
      SELECT 
        id,
        name,
        chzzk_id as chzzkId,
        twitter_username as twitterUsername,
        naver_cafe_user_id as naverCafeUserId,
        cafe_club_id as cafeClubId,
        profile_image_url as profileImageUrl,
        is_active as isActive,
        created_at as createdAt,
        updated_at as updatedAt
      FROM streamers 
      WHERE chzzk_id = ?
    `);
    
    return (stmt.get(chzzkId) as StreamerData) || null;
  }

  async getStreamersWithNotificationSettings(): Promise<any[]> {
    const stmt = this.getPreparedStatement('withSettings', `
      SELECT 
        s.*,
        GROUP_CONCAT(
          JSON_OBJECT(
            'platform', ns.platform,
            'enabled', ns.enabled
          )
        ) as notificationSettings
      FROM streamers s
      LEFT JOIN notification_settings ns ON s.id = ns.streamer_id
      WHERE s.is_active = 1
      GROUP BY s.id
      ORDER BY s.name
    `);
    
    const results = stmt.all() as any[];
    
    // JSON ë¬¸ìì—´ì„ ê°ì²´ë¡œ íŒŒì‹±
    return results.map(row => ({
      ...row,
      notificationSettings: row.notificationSettings 
        ? JSON.parse(`[${row.notificationSettings}]`)
        : []
    }));
  }
}
```

### ì‹¤ìŠµ 2: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ë§
```typescript
// src/main/database/ConnectionPool.ts
import Database from 'better-sqlite3';
import * as path from 'path';
import { app } from 'electron';

export class DatabaseConnectionPool {
  private static instance: DatabaseConnectionPool;
  private connections: Database.Database[] = [];
  private availableConnections: Database.Database[] = [];
  private busyConnections: Set<Database.Database> = new Set();
  private maxConnections: number = 5;
  private dbPath: string;

  private constructor() {
    this.dbPath = path.join(app.getPath('userData'), 'streamer_alarm.db');
  }

  static getInstance(): DatabaseConnectionPool {
    if (!DatabaseConnectionPool.instance) {
      DatabaseConnectionPool.instance = new DatabaseConnectionPool();
    }
    return DatabaseConnectionPool.instance;
  }

  async initialize(): Promise<void> {
    for (let i = 0; i < this.maxConnections; i++) {
      const connection = this.createConnection();
      this.connections.push(connection);
      this.availableConnections.push(connection);
    }
  }

  private createConnection(): Database.Database {
    const db = new Database(this.dbPath);
    
    // ì—°ê²°ë³„ ìµœì í™” ì„¤ì •
    db.pragma('journal_mode = WAL');
    db.pragma('synchronous = NORMAL');
    db.pragma('cache_size = 1000');
    db.pragma('foreign_keys = ON');
    
    return db;
  }

  async getConnection(): Promise<Database.Database> {
    return new Promise((resolve, reject) => {
      if (this.availableConnections.length > 0) {
        const connection = this.availableConnections.pop()!;
        this.busyConnections.add(connection);
        resolve(connection);
      } else {
        // ëª¨ë“  ì—°ê²°ì´ ì‚¬ìš© ì¤‘ì¸ ê²½ìš° ëŒ€ê¸°
        const checkInterval = setInterval(() => {
          if (this.availableConnections.length > 0) {
            clearInterval(checkInterval);
            const connection = this.availableConnections.pop()!;
            this.busyConnections.add(connection);
            resolve(connection);
          }
        }, 10);
        
        // íƒ€ì„ì•„ì›ƒ ì„¤ì • (5ì´ˆ)
        setTimeout(() => {
          clearInterval(checkInterval);
          reject(new Error('Database connection timeout'));
        }, 5000);
      }
    });
  }

  releaseConnection(connection: Database.Database): void {
    if (this.busyConnections.has(connection)) {
      this.busyConnections.delete(connection);
      this.availableConnections.push(connection);
    }
  }

  async executeWithConnection<T>(operation: (db: Database.Database) => T | Promise<T>): Promise<T> {
    const connection = await this.getConnection();
    
    try {
      const result = await operation(connection);
      return result;
    } finally {
      this.releaseConnection(connection);
    }
  }

  async close(): Promise<void> {
    for (const connection of this.connections) {
      connection.close();
    }
    
    this.connections = [];
    this.availableConnections = [];
    this.busyConnections.clear();
  }

  getStatus(): { total: number; available: number; busy: number } {
    return {
      total: this.connections.length,
      available: this.availableConnections.length,
      busy: this.busyConnections.size
    };
  }
}
```

## ğŸ“‹ ì‹¤ìŠµ ê³¼ì œ

### ê¸°ë³¸ ê³¼ì œ
1. **Repository íŒ¨í„´**: NotificationRepositoryì™€ WeverseArtistRepository êµ¬í˜„
2. **ë§ˆì´ê·¸ë ˆì´ì…˜**: ìƒˆë¡œìš´ í…Œì´ë¸” ì¶”ê°€ë¥¼ ìœ„í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±
3. **ì¸ë±ìŠ¤ ìµœì í™”**: ì¿¼ë¦¬ ì„±ëŠ¥ ë¶„ì„ í›„ ì ì ˆí•œ ì¸ë±ìŠ¤ ì„¤ê³„
4. **íŠ¸ëœì­ì…˜**: ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ êµ¬í˜„

### ì‘ìš© ê³¼ì œ
1. **ë°ì´í„° ê²€ì¦**: ë°ì´í„°ë² ì´ìŠ¤ ë ˆë²¨ì—ì„œì˜ ì œì•½ì¡°ê±´ê³¼ íŠ¸ë¦¬ê±° êµ¬í˜„
2. **ë°±ì—…/ë³µì›**: ìë™ ë°±ì—… ì‹œìŠ¤í…œê³¼ ë°ì´í„° ë³µì› ê¸°ëŠ¥
3. **ì¿¼ë¦¬ ë¹Œë”**: ë™ì  ì¿¼ë¦¬ ìƒì„±ì„ ìœ„í•œ íƒ€ì… ì•ˆì „í•œ ì¿¼ë¦¬ ë¹Œë”
4. **ì—°ê²° í’€**: ë™ì‹œ ì ‘ê·¼ ìµœì í™”ë¥¼ ìœ„í•œ ì—°ê²° í’€ êµ¬í˜„

### ë„ì „ ê³¼ì œ
1. **ì½ê¸° ì „ìš© ë³µì œ**: ì½ê¸° ì„±ëŠ¥ í–¥ìƒì„ ìœ„í•œ ì½ê¸° ì „ìš© ë°ì´í„°ë² ì´ìŠ¤ ë³µì œ
2. **íŒŒí‹°ì…”ë‹**: ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ë¥¼ ìœ„í•œ í…Œì´ë¸” íŒŒí‹°ì…”ë‹
3. **ìºì‹œ ë ˆì´ì–´**: Redisë¥¼ í™œìš©í•œ ë°ì´í„°ë² ì´ìŠ¤ ìºì‹œ ë ˆì´ì–´
4. **ë¶„ì„ ì¿¼ë¦¬**: í†µê³„ ë° ë¶„ì„ì„ ìœ„í•œ ë³µì¡í•œ ì§‘ê³„ ì¿¼ë¦¬

## ğŸ¯ í•™ìŠµ ì •ë¦¬

### í•µì‹¬ ê°œë… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] **ë°ì´í„° ëª¨ë¸ë§**: ì •ê·œí™”ì™€ ê´€ê³„ ì„¤ê³„ì˜ ì›ì¹™
- [ ] **ë§ˆì´ê·¸ë ˆì´ì…˜**: ì•ˆì „í•œ ìŠ¤í‚¤ë§ˆ ë³€ê²½ ì „ëµ
- [ ] **ì„±ëŠ¥ ìµœì í™”**: ì¸ë±ì‹±ê³¼ ì¿¼ë¦¬ ìµœì í™” ê¸°ë²•
- [ ] **íŠ¸ëœì­ì…˜**: ACID ì†ì„±ê³¼ ë™ì‹œì„± ì œì–´
- [ ] **íŒ¨í„´ ì ìš©**: Repository íŒ¨í„´ê³¼ ë°ì´í„° ì ‘ê·¼ ê³„ì¸µ

### ì‹¤ë¬´ ì ìš© í¬ì¸íŠ¸
1. **ë°ì´í„° ë¬´ê²°ì„±**: ì œì•½ì¡°ê±´ê³¼ ê²€ì¦ì„ í†µí•œ ë°ì´í„° í’ˆì§ˆ ë³´ì¥
2. **í™•ì¥ì„±**: ë§ˆì´ê·¸ë ˆì´ì…˜ì„ í†µí•œ ì ì§„ì  ìŠ¤í‚¤ë§ˆ ë°œì „
3. **ì„±ëŠ¥**: ì¸ë±ìŠ¤ì™€ ì¿¼ë¦¬ ìµœì í™”ë¥¼ í†µí•œ ì‘ë‹µ ì‹œê°„ ë‹¨ì¶•
4. **ìœ ì§€ë³´ìˆ˜**: Repository íŒ¨í„´ì„ í†µí•œ ë°ì´í„° ì ‘ê·¼ ë¡œì§ ë¶„ë¦¬

---
*ğŸ—„ï¸ **9ì¼ì°¨ ì™„ë£Œ!** ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ë¶€í„° ê³ ê¸‰ ìµœì í™” ê¸°ë²•ê¹Œì§€ í¬ê´„ì ìœ¼ë¡œ í•™ìŠµí–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë‹¨ê³„ì—ì„œëŠ” ì‹œìŠ¤í…œ ì•Œë¦¼ê³¼ íŠ¸ë ˆì´ í†µí•©ì„ í†µí•œ ë„¤ì´í‹°ë¸Œ OS ê¸°ëŠ¥ í™œìš©ì„ ë‹¤ë¤„ë³´ê² ìŠµë‹ˆë‹¤.*