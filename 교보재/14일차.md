# ğŸ” 14ì¼ì°¨: ì—ëŸ¬ ì²˜ë¦¬ì™€ ë¡œê¹…

> **í•™ìŠµ ëª©í‘œ**: Winston ê¸°ë°˜ êµ¬ì¡°í™”ëœ ë¡œê¹… ì‹œìŠ¤í…œê³¼ ì „ì—­ ì—ëŸ¬ ì²˜ë¦¬ ë©”ì»¤ë‹ˆì¦˜ìœ¼ë¡œ í”„ë¡œë•ì…˜ í’ˆì§ˆì˜ ì—ëŸ¬ ì¶”ì  ì‹œìŠ¤í…œ êµ¬í˜„

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

### í•µì‹¬ ëª©í‘œ
- Winstonì„ í™œìš©í•œ ì¹´í…Œê³ ë¦¬ë³„ êµ¬ì¡°í™”ëœ ë¡œê¹… ì‹œìŠ¤í…œ êµ¬í˜„
- ì „ì—­ ì—ëŸ¬ ì²˜ë¦¬ ë©”ì»¤ë‹ˆì¦˜ê³¼ ì—ëŸ¬ ë³µêµ¬ ì „ëµ ì„¤ê³„
- ë¡œê·¸ íšŒì „, ì••ì¶•, ì •ë¦¬ë¥¼ í†µí•œ íš¨ìœ¨ì ì¸ ë¡œê·¸ ê´€ë¦¬
- ê°œë°œ/í”„ë¡œë•ì…˜ í™˜ê²½ë³„ ë¡œê¹… ì „ëµ êµ¬í˜„

### ì‹¤ë¬´ ì—­ëŸ‰
- ì‹¤ì‹œê°„ ë¡œê·¸ ëª¨ë‹ˆí„°ë§ê³¼ ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬ì¶•
- ì—ëŸ¬ ì¶”ì ê³¼ ë””ë²„ê¹…ì„ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ìˆ˜ì§‘
- ì„±ëŠ¥ì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ” ë¡œê¹… ì‹œìŠ¤í…œ ì„¤ê³„
- ìš´ì˜ í™˜ê²½ì—ì„œì˜ ë¬¸ì œ ì§„ë‹¨ê³¼ í•´ê²° ëŠ¥ë ¥

---

## ğŸ“š ì´ë¡  í•™ìŠµ

### 1. ë¡œê¹… ì‹œìŠ¤í…œì˜ ì„¤ê³„ ì›ì¹™

#### êµ¬ì¡°í™”ëœ ë¡œê¹… (Structured Logging)
```typescript
// ì „í†µì ì¸ ë¬¸ìì—´ ê¸°ë°˜ ë¡œê¹…ì˜ í•œê³„
console.log(`User ${userId} failed to login at ${new Date()}`);
// â†’ íŒŒì‹±ì´ ì–´ë µê³ , ê²€ìƒ‰ê³¼ í•„í„°ë§ì´ ì œí•œì 

// êµ¬ì¡°í™”ëœ ë¡œê¹…ì˜ ì¥ì 
logger.error('Login failed', {
  userId: 12345,
  timestamp: new Date().toISOString(),
  error: 'Invalid password',
  ip: '192.168.1.1',
  userAgent: 'Chrome/91.0'
});
// â†’ JSONìœ¼ë¡œ êµ¬ì¡°í™”ë˜ì–´ ê²€ìƒ‰, í•„í„°ë§, ë¶„ì„ì´ ìš©ì´
```

#### ë¡œê·¸ ë ˆë²¨ ì „ëµ
```typescript
enum LogLevel {
  ERROR = 'error',    // ì‹œìŠ¤í…œ ì˜¤ë¥˜, ì¦‰ì‹œ ì¡°ì¹˜ í•„ìš”
  WARN = 'warn',      // ê²½ê³ , ì ì¬ì  ë¬¸ì œ ìƒí™©
  INFO = 'info',      // ì¼ë°˜ì ì¸ ì •ë³´ì„± ë©”ì‹œì§€
  DEBUG = 'debug'     // ë””ë²„ê¹…ìš© ìƒì„¸ ì •ë³´
}

// í™˜ê²½ë³„ ë¡œê·¸ ë ˆë²¨ ì„¤ì •
const getLogLevel = (): string => {
  if (process.env.NODE_ENV === 'production') return 'info';
  if (process.env.NODE_ENV === 'test') return 'warn';
  return 'debug'; // development
};
```

### 2. ì¹´í…Œê³ ë¦¬ë³„ ë¡œê¹… íŒ¨í„´

#### ë„ë©”ì¸ ê¸°ë°˜ ë¡œê·¸ ë¶„ë¦¬
```typescript
// ê° ë„ë©”ì¸ë³„ë¡œ ë³„ë„ì˜ ë¡œê·¸ íŒŒì¼ê³¼ ë¡œê±° ìƒì„±
enum LogCategory {
  DATABASE = 'database',      // ë°ì´í„°ë² ì´ìŠ¤ ê´€ë ¨
  WEVERSE = 'weverse',        // ìœ„ë²„ìŠ¤ ëª¨ë‹ˆí„°ë§
  NOTIFICATION = 'notification', // ì•Œë¦¼ ì‹œìŠ¤í…œ
  SESSION = 'session',        // ì„¸ì…˜ ê´€ë¦¬
  MONITORING = 'monitoring'   // ì¼ë°˜ ëª¨ë‹ˆí„°ë§
}

// ê° ì¹´í…Œê³ ë¦¬ë³„ ë…ë¦½ì ì¸ ì„¤ì •
const createCategoryLogger = (category: LogCategory) => {
  return winston.createLogger({
    level: getLogLevel(),
    defaultMeta: { category },
    transports: [
      new winston.transports.File({
        filename: `logs/${category}.log`,
        maxsize: 10 * 1024 * 1024,  // 10MB
        maxFiles: 5,
        tailable: true
      })
    ]
  });
};
```

### 3. ì „ì—­ ì—ëŸ¬ ì²˜ë¦¬ ì „ëµ

#### Node.js ì „ì—­ ì—ëŸ¬ í•¸ë“¤ëŸ¬
```typescript
// ì²˜ë¦¬ë˜ì§€ ì•Šì€ Promise rejection
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Promise Rejection', {
    reason: reason instanceof Error ? reason.message : reason,
    stack: reason instanceof Error ? reason.stack : undefined,
    promise: promise.toString()
  });
  
  // ì¹˜ëª…ì  ì—ëŸ¬ì˜ ê²½ìš° í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
  if (isCriticalError(reason)) {
    process.exit(1);
  }
});

// ì²˜ë¦¬ë˜ì§€ ì•Šì€ ì˜ˆì™¸
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception', {
    error: error.message,
    stack: error.stack
  });
  
  // ì¹˜ëª…ì ì´ë¯€ë¡œ ì •ë¦¬ ì‘ì—… í›„ ì¢…ë£Œ
  cleanup().then(() => {
    process.exit(1);
  });
});
```

#### Electron íŠ¹í™” ì—ëŸ¬ ì²˜ë¦¬
```typescript
// Renderer í”„ë¡œì„¸ìŠ¤ ì—ëŸ¬
app.on('render-process-gone', (event, webContents, details) => {
  logger.error('Renderer process crashed', {
    reason: details.reason,
    exitCode: details.exitCode,
    url: webContents.getURL()
  });
  
  // ë Œë”ëŸ¬ í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.reload();
  }
});

// ë©”ì¸ í”„ë¡œì„¸ìŠ¤ ì—ëŸ¬
app.on('child-process-gone', (event, details) => {
  logger.error('Child process crashed', {
    type: details.type,
    reason: details.reason,
    exitCode: details.exitCode
  });
});
```

---

## ğŸ” ì½”ë“œ ë¶„ì„

### 1. CategoryLogger ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

#### ì‹±ê¸€í†¤ íŒ¨í„´ ê¸°ë°˜ ë¡œê±° ë§¤ë‹ˆì €
```typescript
export class CategoryLogger {
  private static instance: CategoryLogger;
  private loggers = new Map<LogCategory, winston.Logger>();
  private logDir: string;
  private isInitialized: boolean = false;

  private constructor() {
    const userDataPath = app.getPath('userData');
    this.logDir = path.join(userDataPath, 'logs');
    this.initializeLogDirectory();
  }

  public static getInstance(): CategoryLogger {
    if (!CategoryLogger.instance) {
      CategoryLogger.instance = new CategoryLogger();
    }
    return CategoryLogger.instance;
  }
}
```

#### ë¡œê·¸ ë””ë ‰í† ë¦¬ ì´ˆê¸°í™”ì™€ ì•ˆì „í•œ íŒŒì¼ ìƒì„±
```typescript
/**
 * ë¡œê·¸ ë””ë ‰í† ë¦¬ ì´ˆê¸°í™”
 */
private initializeLogDirectory(): void {
  try {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
    this.isInitialized = true;
  } catch (error) {
    console.error('âŒ Failed to create log directory:', error);
    // ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œì—ë„ ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ê³„ì† ì‹¤í–‰
  }
}
```

### 2. Winston ë¡œê±° ì„¤ì •ê³¼ ìµœì í™”

#### í”„ë¡œë•ì…˜ ìµœì í™”ëœ ë¡œê±° ìƒì„±
```typescript
/**
 * ì¹´í…Œê³ ë¦¬ë³„ ë¡œê±° ìƒì„±
 */
private createLogger(category: LogCategory): winston.Logger {
  const logFile = path.join(this.logDir, `${category}.log`);
  
  const logger = winston.createLogger({
    level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',
    format: winston.format.combine(
      winston.format.timestamp({
        format: 'YYYY-MM-DD HH:mm:ss.SSS'
      }),
      winston.format.errors({ stack: true }),
      winston.format.printf(({ timestamp, level, message, stack, ...meta }: any) => {
        const metaString = Object.keys(meta).length ? ` ${JSON.stringify(meta)}` : '';
        const stackString = stack ? `\n${stack}` : '';
        return `${timestamp} [${level.toUpperCase()}] [${category.toUpperCase()}] ${message}${metaString}${stackString}`;
      })
    ),
    transports: [
      // íŒŒì¼ ë¡œê·¸ (íšŒì „ì‹)
      new winston.transports.File({
        filename: logFile,
        maxsize: 10 * 1024 * 1024, // 10MB
        maxFiles: 5,                // ìµœëŒ€ 5ê°œ íŒŒì¼ ë³´ê´€
        tailable: true,             // ìµœì‹  ë¡œê·¸ê°€ í˜„ì¬ íŒŒì¼ì—
        zippedArchive: true         // ì˜¤ë˜ëœ ë¡œê·¸ ì••ì¶•
      }),
      // ì½˜ì†” ë¡œê·¸ (ê°œë°œ ëª¨ë“œì—ì„œë§Œ)
      ...(process.env.NODE_ENV === 'development' ? [
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.printf(({ timestamp, level, message, ...meta }: any) => {
              const metaString = Object.keys(meta).length ? ` ${JSON.stringify(meta)}` : '';
              return `${timestamp} [${level}] [${category.toUpperCase()}] ${message}${metaString}`;
            })
          )
        })
      ] : [])
    ]
  });

  return logger;
}
```

#### ì•ˆì „í•œ ë¡œê±° ì ‘ê·¼ê³¼ í´ë°± ë©”ì»¤ë‹ˆì¦˜
```typescript
/**
 * ì¹´í…Œê³ ë¦¬ë³„ ë¡œê±° ê°€ì ¸ì˜¤ê¸°
 */
public getLogger(category: LogCategory): winston.Logger {
  if (!this.isInitialized) {
    console.warn('âš ï¸ CategoryLogger not properly initialized, falling back to console');
    return this.createFallbackLogger(category);
  }

  if (!this.loggers.has(category)) {
    this.loggers.set(category, this.createLogger(category));
  }
  
  return this.loggers.get(category)!;
}

/**
 * í´ë°± ë¡œê±° ìƒì„± (ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ)
 */
private createFallbackLogger(category: LogCategory): winston.Logger {
  return winston.createLogger({
    level: 'info',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.printf(({ timestamp, level, message }: any) => {
        return `${timestamp} [${level.toUpperCase()}] [${category.toUpperCase()}] ${message}`;
      })
    ),
    transports: [
      new winston.transports.Console()
    ]
  });
}
```

### 3. í¸ì˜ì„±ê³¼ íƒ€ì… ì•ˆì „ì„±ì„ ìœ„í•œ ë˜í¼

#### ì¹´í…Œê³ ë¦¬ë³„ ë¡œê±° í¸ì˜ í•¨ìˆ˜
```typescript
/**
 * ì¹´í…Œê³ ë¦¬ë³„ ë¡œê±° í¸ì˜ í•¨ìˆ˜ë“¤
 */
export const weverseLogger = {
  error: (message: string, meta?: any) => logger.error(LogCategory.WEVERSE, message, meta),
  warn: (message: string, meta?: any) => logger.warn(LogCategory.WEVERSE, message, meta),
  info: (message: string, meta?: any) => logger.info(LogCategory.WEVERSE, message, meta),
  debug: (message: string, meta?: any) => logger.debug(LogCategory.WEVERSE, message, meta)
};

export const databaseLogger = {
  error: (message: string, meta?: any) => logger.error(LogCategory.DATABASE, message, meta),
  warn: (message: string, meta?: any) => logger.warn(LogCategory.DATABASE, message, meta),
  info: (message: string, meta?: any) => logger.info(LogCategory.DATABASE, message, meta),
  debug: (message: string, meta?: any) => logger.debug(LogCategory.DATABASE, message, meta)
};

export const sessionLogger = {
  error: (message: string, meta?: any) => logger.error(LogCategory.SESSION, message, meta),
  warn: (message: string, meta?: any) => logger.warn(LogCategory.SESSION, message, meta),
  info: (message: string, meta?: any) => logger.info(LogCategory.SESSION, message, meta),
  debug: (message: string, meta?: any) => logger.debug(LogCategory.SESSION, message, meta)
};
```

### 4. ë¡œê·¸ ê´€ë¦¬ ë° ìœ ì§€ë³´ìˆ˜

#### ìë™ ë¡œê·¸ ì •ë¦¬ ì‹œìŠ¤í…œ
```typescript
/**
 * ë¡œê·¸ íŒŒì¼ ì •ë¦¬ (ì˜¤ë˜ëœ ë¡œê·¸ ì‚­ì œ)
 */
public async cleanupLogs(daysToKeep: number = 30): Promise<void> {
  try {
    if (!fs.existsSync(this.logDir)) return;

    const files = fs.readdirSync(this.logDir);
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

    for (const file of files) {
      const filePath = path.join(this.logDir, file);
      const stats = fs.statSync(filePath);
      
      if (stats.mtime < cutoffDate) {
        fs.unlinkSync(filePath);
        console.log(`ğŸ—‘ï¸ Removed old log file: ${file}`);
      }
    }
  } catch (error) {
    console.error('âŒ Failed to cleanup logs:', error);
  }
}
```

#### ë¡œê·¸ í†µê³„ ë° ëª¨ë‹ˆí„°ë§
```typescript
/**
 * ë¡œê·¸ í†µê³„ ì¡°íšŒ
 */
public getLogStats(): { [key in LogCategory]?: { size: number; lastModified: Date } } {
  const stats: { [key in LogCategory]?: { size: number; lastModified: Date } } = {};

  try {
    if (!fs.existsSync(this.logDir)) return stats;

    for (const category of Object.values(LogCategory)) {
      const logFile = path.join(this.logDir, `${category}.log`);
      
      if (fs.existsSync(logFile)) {
        const fileStat = fs.statSync(logFile);
        stats[category] = {
          size: fileStat.size,
          lastModified: fileStat.mtime
        };
      }
    }
  } catch (error) {
    console.error('âŒ Failed to get log stats:', error);
  }

  return stats;
}
```

---

## ğŸ› ï¸ ì‹¤ìŠµ ì˜ˆì œ

### 1. êµ¬ì¡°í™”ëœ ë¡œê¹… ì‹œìŠ¤í…œ êµ¬í˜„

#### Step 1: ê¸°ë³¸ ë¡œê¹… ì¸í„°í˜ì´ìŠ¤ ì •ì˜
```typescript
// src/main/services/Logger.ts
export interface LogContext {
  userId?: string;
  sessionId?: string;
  requestId?: string;
  action?: string;
  duration?: number;
  [key: string]: any;
}

export interface ILogger {
  error(message: string, context?: LogContext): void;
  warn(message: string, context?: LogContext): void;
  info(message: string, context?: LogContext): void;
  debug(message: string, context?: LogContext): void;
}

class StructuredLogger implements ILogger {
  private logger: winston.Logger;
  private category: string;
  
  constructor(category: string) {
    this.category = category;
    this.logger = winston.createLogger({
      level: this.getLogLevel(),
      format: winston.format.combine(
        winston.format.timestamp({
          format: 'YYYY-MM-DD HH:mm:ss.SSS'
        }),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      defaultMeta: {
        category: this.category,
        pid: process.pid,
        hostname: require('os').hostname()
      },
      transports: [
        new winston.transports.File({
          filename: `logs/${category}.log`,
          maxsize: 10 * 1024 * 1024,
          maxFiles: 5,
          tailable: true
        }),
        ...(process.env.NODE_ENV === 'development' ? [
          new winston.transports.Console({
            format: winston.format.combine(
              winston.format.colorize(),
              winston.format.simple()
            )
          })
        ] : [])
      ]
    });
  }
  
  error(message: string, context?: LogContext): void {
    this.logger.error(message, context);
  }
  
  warn(message: string, context?: LogContext): void {
    this.logger.warn(message, context);
  }
  
  info(message: string, context?: LogContext): void {
    this.logger.info(message, context);
  }
  
  debug(message: string, context?: LogContext): void {
    this.logger.debug(message, context);
  }
  
  private getLogLevel(): string {
    return process.env.LOG_LEVEL || 
           (process.env.NODE_ENV === 'production' ? 'info' : 'debug');
  }
}
```

#### Step 2: ì»¨í…ìŠ¤íŠ¸ ì¶”ì  ì‹œìŠ¤í…œ
```typescript
// src/main/services/LoggingContext.ts
import { AsyncLocalStorage } from 'async_hooks';

interface RequestContext {
  requestId: string;
  userId?: string;
  sessionId?: string;
  startTime: number;
}

class LoggingContextManager {
  private static instance: LoggingContextManager;
  private asyncLocalStorage = new AsyncLocalStorage<RequestContext>();
  
  static getInstance(): LoggingContextManager {
    if (!LoggingContextManager.instance) {
      LoggingContextManager.instance = new LoggingContextManager();
    }
    return LoggingContextManager.instance;
  }
  
  runWithContext<T>(context: Partial<RequestContext>, callback: () => T): T {
    const fullContext: RequestContext = {
      requestId: this.generateRequestId(),
      startTime: Date.now(),
      ...context
    };
    
    return this.asyncLocalStorage.run(fullContext, callback);
  }
  
  getContext(): RequestContext | undefined {
    return this.asyncLocalStorage.getStore();
  }
  
  getCurrentRequestId(): string | undefined {
    return this.getContext()?.requestId;
  }
  
  getCurrentUserId(): string | undefined {
    return this.getContext()?.userId;
  }
  
  setUserId(userId: string): void {
    const context = this.getContext();
    if (context) {
      context.userId = userId;
    }
  }
  
  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// ì»¨í…ìŠ¤íŠ¸ë¥¼ ìë™ìœ¼ë¡œ í¬í•¨í•˜ëŠ” ë¡œê±°
class ContextAwareLogger extends StructuredLogger {
  private contextManager = LoggingContextManager.getInstance();
  
  private enrichContext(context?: LogContext): LogContext {
    const currentContext = this.contextManager.getContext();
    return {
      ...context,
      ...currentContext ? {
        requestId: currentContext.requestId,
        userId: currentContext.userId,
        sessionId: currentContext.sessionId,
        requestDuration: Date.now() - currentContext.startTime
      } : {}
    };
  }
  
  error(message: string, context?: LogContext): void {
    super.error(message, this.enrichContext(context));
  }
  
  warn(message: string, context?: LogContext): void {
    super.warn(message, this.enrichContext(context));
  }
  
  info(message: string, context?: LogContext): void {
    super.info(message, this.enrichContext(context));
  }
  
  debug(message: string, context?: LogContext): void {
    super.debug(message, this.enrichContext(context));
  }
}
```

### 2. ì „ì—­ ì—ëŸ¬ ì²˜ë¦¬ ì‹œìŠ¤í…œ

#### Step 1: í¬ê´„ì ì¸ ì—ëŸ¬ í•¸ë“¤ëŸ¬
```typescript
// src/main/services/ErrorHandler.ts
class GlobalErrorHandler {
  private logger: ContextAwareLogger;
  private crashReporter: CrashReporter;
  
  constructor() {
    this.logger = new ContextAwareLogger('error');
    this.crashReporter = new CrashReporter();
    this.setupGlobalHandlers();
  }
  
  private setupGlobalHandlers(): void {
    // ì²˜ë¦¬ë˜ì§€ ì•Šì€ Promise rejection
    process.on('unhandledRejection', (reason, promise) => {
      this.handleUnhandledRejection(reason, promise);
    });
    
    // ì²˜ë¦¬ë˜ì§€ ì•Šì€ ì˜ˆì™¸
    process.on('uncaughtException', (error) => {
      this.handleUncaughtException(error);
    });
    
    // Electron íŠ¹í™” ì—ëŸ¬ í•¸ë“¤ëŸ¬
    if (typeof app !== 'undefined') {
      this.setupElectronHandlers();
    }
  }
  
  private handleUnhandledRejection(reason: any, promise: Promise<any>): void {
    const error = reason instanceof Error ? reason : new Error(String(reason));
    
    this.logger.error('Unhandled Promise Rejection', {
      error: error.message,
      stack: error.stack,
      promise: promise.toString(),
      type: 'unhandledRejection'
    });
    
    // ë¹„ë™ê¸° ì—ëŸ¬ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì¹˜ëª…ì ì´ì§€ ì•ŠìŒ
    this.reportError(error, { type: 'unhandledRejection' });
  }
  
  private handleUncaughtException(error: Error): void {
    this.logger.error('Uncaught Exception - Process will exit', {
      error: error.message,
      stack: error.stack,
      type: 'uncaughtException'
    });
    
    // ì¹˜ëª…ì  ì—ëŸ¬ì´ë¯€ë¡œ í¬ë˜ì‹œ ë¦¬í¬íŠ¸ í›„ ì¢…ë£Œ
    this.reportError(error, { type: 'uncaughtException', fatal: true });
    
    // ì •ë¦¬ ì‘ì—… í›„ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
    this.gracefulShutdown(1);
  }
  
  private setupElectronHandlers(): void {
    app.on('render-process-gone', (event, webContents, details) => {
      this.logger.error('Renderer process crashed', {
        reason: details.reason,
        exitCode: details.exitCode,
        url: webContents.getURL(),
        type: 'renderProcessGone'
      });
      
      this.handleRendererCrash(webContents, details);
    });
    
    app.on('child-process-gone', (event, details) => {
      this.logger.error('Child process crashed', {
        type: details.type,
        reason: details.reason,
        exitCode: details.exitCode,
        name: details.name
      });
    });
  }
  
  private handleRendererCrash(webContents: Electron.WebContents, details: any): void {
    // ë Œë”ëŸ¬ í”„ë¡œì„¸ìŠ¤ ì¬ì‹œì‘ ì‹œë„
    if (!webContents.isDestroyed()) {
      setTimeout(() => {
        try {
          webContents.reload();
          this.logger.info('Renderer process restarted after crash');
        } catch (reloadError) {
          this.logger.error('Failed to restart renderer process', {
            error: reloadError.message
          });
        }
      }, 1000);
    }
  }
  
  private reportError(error: Error, context?: any): void {
    try {
      this.crashReporter.reportError(error, context);
    } catch (reportingError) {
      console.error('Failed to report error:', reportingError);
    }
  }
  
  private gracefulShutdown(exitCode: number): void {
    console.log('Initiating graceful shutdown...');
    
    // ì •ë¦¬ ì‘ì—… (ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì¢…ë£Œ, íŒŒì¼ ì €ì¥ ë“±)
    Promise.all([
      this.cleanupResources(),
      this.saveUnsavedData()
    ]).then(() => {
      console.log('Graceful shutdown completed');
      process.exit(exitCode);
    }).catch((cleanupError) => {
      console.error('Error during cleanup:', cleanupError);
      process.exit(exitCode);
    });
  }
  
  private async cleanupResources(): Promise<void> {
    // ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ë¡œì§
    // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì¢…ë£Œ, íŒŒì¼ í•¸ë“¤ ì •ë¦¬ ë“±
  }
  
  private async saveUnsavedData(): Promise<void> {
    // ì €ì¥ë˜ì§€ ì•Šì€ ë°ì´í„° ì €ì¥ ë¡œì§
  }
}
```

#### Step 2: í¬ë˜ì‹œ ë¦¬í¬íŒ… ì‹œìŠ¤í…œ
```typescript
// src/main/services/CrashReporter.ts
interface CrashReport {
  error: {
    message: string;
    stack?: string;
    name: string;
  };
  context: {
    timestamp: string;
    version: string;
    platform: string;
    arch: string;
    nodeVersion: string;
    electronVersion?: string;
    type: string;
    fatal?: boolean;
  };
  system: {
    totalMemory: number;
    freeMemory: number;
    cpuUsage: any;
    uptime: number;
  };
  user?: {
    userId?: string;
    sessionId?: string;
  };
}

class CrashReporter {
  private logger: StructuredLogger;
  private contextManager = LoggingContextManager.getInstance();
  
  constructor() {
    this.logger = new StructuredLogger('crash');
  }
  
  reportError(error: Error, context?: any): void {
    const report = this.createCrashReport(error, context);
    
    // ë¡œì»¬ ì €ì¥
    this.saveLocalReport(report);
    
    // ì›ê²© ì „ì†¡ (ì„ íƒì‚¬í•­)
    this.sendRemoteReport(report).catch(sendError => {
      this.logger.error('Failed to send crash report', {
        error: sendError.message,
        originalError: error.message
      });
    });
  }
  
  private createCrashReport(error: Error, context?: any): CrashReport {
    const currentContext = this.contextManager.getContext();
    
    return {
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name
      },
      context: {
        timestamp: new Date().toISOString(),
        version: require('../../../package.json').version,
        platform: process.platform,
        arch: process.arch,
        nodeVersion: process.version,
        electronVersion: process.versions.electron,
        type: context?.type || 'unknown',
        fatal: context?.fatal || false
      },
      system: {
        totalMemory: require('os').totalmem(),
        freeMemory: require('os').freemem(),
        cpuUsage: process.cpuUsage(),
        uptime: process.uptime()
      },
      user: currentContext ? {
        userId: currentContext.userId,
        sessionId: currentContext.sessionId
      } : undefined
    };
  }
  
  private saveLocalReport(report: CrashReport): void {
    try {
      const fs = require('fs');
      const path = require('path');
      const { app } = require('electron');
      
      const crashDir = path.join(app.getPath('userData'), 'crashes');
      if (!fs.existsSync(crashDir)) {
        fs.mkdirSync(crashDir, { recursive: true });
      }
      
      const filename = `crash_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.json`;
      const filepath = path.join(crashDir, filename);
      
      fs.writeFileSync(filepath, JSON.stringify(report, null, 2));
      
      this.logger.info('Crash report saved locally', { filepath });
    } catch (saveError) {
      console.error('Failed to save crash report locally:', saveError);
    }
  }
  
  private async sendRemoteReport(report: CrashReport): Promise<void> {
    // ì›ê²© í¬ë˜ì‹œ ë¦¬í¬íŒ… ì„œë¹„ìŠ¤ë¡œ ì „ì†¡
    // ì˜ˆ: Sentry, Bugsnag, ìì²´ ì„œë²„ ë“±
    
    // ì˜ˆì œ: ê°„ë‹¨í•œ HTTP POST
    const https = require('https');
    
    return new Promise((resolve, reject) => {
      const data = JSON.stringify(report);
      
      const options = {
        hostname: 'crash-reports.example.com',
        port: 443,
        path: '/api/crashes',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': data.length
        }
      };
      
      const req = https.request(options, (res) => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve();
        } else {
          reject(new Error(`HTTP ${res.statusCode}`));
        }
      });
      
      req.on('error', reject);
      req.write(data);
      req.end();
    });
  }
}
```

### 3. ì„±ëŠ¥ ì˜í–¥ì„ ìµœì†Œí™”í•˜ëŠ” ë¡œê¹…

#### Step 1: ë¹„ë™ê¸° ë¡œê¹… í
```typescript
// src/main/services/AsyncLogger.ts
interface LogEntry {
  level: string;
  message: string;
  context?: any;
  timestamp: number;
}

class AsyncLoggerQueue {
  private queue: LogEntry[] = [];
  private isProcessing: boolean = false;
  private batchSize: number = 100;
  private flushInterval: number = 1000; // 1ì´ˆ
  private timer: NodeJS.Timeout | null = null;
  private logger: winston.Logger;
  
  constructor(logger: winston.Logger) {
    this.logger = logger;
    this.startFlushTimer();
  }
  
  enqueue(entry: LogEntry): void {
    this.queue.push(entry);
    
    // íê°€ ê°€ë“ ì°¬ ê²½ìš° ì¦‰ì‹œ í”ŒëŸ¬ì‹œ
    if (this.queue.length >= this.batchSize) {
      this.flush();
    }
  }
  
  private startFlushTimer(): void {
    this.timer = setInterval(() => {
      if (this.queue.length > 0) {
        this.flush();
      }
    }, this.flushInterval);
  }
  
  private async flush(): Promise<void> {
    if (this.isProcessing || this.queue.length === 0) return;
    
    this.isProcessing = true;
    const batch = this.queue.splice(0, this.batchSize);
    
    try {
      // ë°°ì¹˜ ë‹¨ìœ„ë¡œ ë¡œê·¸ ì²˜ë¦¬
      for (const entry of batch) {
        this.logger.log(entry.level, entry.message, entry.context);
      }
    } catch (error) {
      // ë¡œê¹… ì‹¤íŒ¨ ì‹œ íì— ë‹¤ì‹œ ì¶”ê°€ (ì¬ì‹œë„)
      this.queue.unshift(...batch);
      console.error('Failed to flush log batch:', error);
    } finally {
      this.isProcessing = false;
    }
  }
  
  async shutdown(): Promise<void> {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
    
    // ë‚¨ì€ ë¡œê·¸ ëª¨ë‘ í”ŒëŸ¬ì‹œ
    await this.flush();
  }
}

class HighPerformanceLogger implements ILogger {
  private loggerQueue: AsyncLoggerQueue;
  
  constructor(category: string) {
    const baseLogger = winston.createLogger({
      // winston ì„¤ì •...
    });
    
    this.loggerQueue = new AsyncLoggerQueue(baseLogger);
  }
  
  error(message: string, context?: LogContext): void {
    this.loggerQueue.enqueue({
      level: 'error',
      message,
      context,
      timestamp: Date.now()
    });
  }
  
  warn(message: string, context?: LogContext): void {
    this.loggerQueue.enqueue({
      level: 'warn',
      message,
      context,
      timestamp: Date.now()
    });
  }
  
  info(message: string, context?: LogContext): void {
    this.loggerQueue.enqueue({
      level: 'info',
      message,
      context,
      timestamp: Date.now()
    });
  }
  
  debug(message: string, context?: LogContext): void {
    // ê°œë°œ ëª¨ë“œê°€ ì•„ë‹ˆë©´ ìŠ¤í‚µí•˜ì—¬ ì„±ëŠ¥ í–¥ìƒ
    if (process.env.NODE_ENV !== 'development') return;
    
    this.loggerQueue.enqueue({
      level: 'debug',
      message,
      context,
      timestamp: Date.now()
    });
  }
}
```

### 4. ì‹¤ì‹œê°„ ë¡œê·¸ ëª¨ë‹ˆí„°ë§

#### Step 1: ë¡œê·¸ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
```typescript
// src/main/services/LogMonitor.ts
interface AlertRule {
  pattern: RegExp;
  threshold: number;      // ì‹œê°„ë‹¹ ë°œìƒ íšŸìˆ˜
  timeWindow: number;     // ì‹œê°„ ìœˆë„ìš° (ë°€ë¦¬ì´ˆ)
  alertLevel: 'warn' | 'critical';
}

class LogMonitor {
  private alertRules: AlertRule[] = [];
  private eventCounts = new Map<string, number[]>();
  private notificationService: any; // NotificationService
  
  constructor(notificationService: any) {
    this.notificationService = notificationService;
    this.setupDefaultRules();
    this.startCleanupTimer();
  }
  
  private setupDefaultRules(): void {
    this.alertRules = [
      {
        pattern: /ERROR/,
        threshold: 10,
        timeWindow: 60 * 1000, // 1ë¶„
        alertLevel: 'warn'
      },
      {
        pattern: /CRITICAL|FATAL/,
        threshold: 1,
        timeWindow: 60 * 1000,
        alertLevel: 'critical'
      },
      {
        pattern: /database.*connection.*failed/i,
        threshold: 3,
        timeWindow: 5 * 60 * 1000, // 5ë¶„
        alertLevel: 'critical'
      }
    ];
  }
  
  processLogEntry(level: string, message: string): void {
    const logLine = `${level.toUpperCase()} ${message}`;
    const now = Date.now();
    
    for (const rule of this.alertRules) {
      if (rule.pattern.test(logLine)) {
        this.recordEvent(rule, now);
        this.checkThreshold(rule, now);
      }
    }
  }
  
  private recordEvent(rule: AlertRule, timestamp: number): void {
    const key = rule.pattern.toString();
    if (!this.eventCounts.has(key)) {
      this.eventCounts.set(key, []);
    }
    
    this.eventCounts.get(key)!.push(timestamp);
  }
  
  private checkThreshold(rule: AlertRule, now: number): void {
    const key = rule.pattern.toString();
    const events = this.eventCounts.get(key) || [];
    
    // ì‹œê°„ ìœˆë„ìš° ë‚´ì˜ ì´ë²¤íŠ¸ë§Œ ì¹´ìš´íŠ¸
    const recentEvents = events.filter(timestamp => 
      now - timestamp <= rule.timeWindow
    );
    
    if (recentEvents.length >= rule.threshold) {
      this.triggerAlert(rule, recentEvents.length);
      
      // ì•Œë¦¼ í›„ ì¹´ìš´í„° ë¦¬ì…‹ (ìŠ¤íŒ¸ ë°©ì§€)
      this.eventCounts.set(key, []);
    }
  }
  
  private triggerAlert(rule: AlertRule, eventCount: number): void {
    const alertMessage = `Log alert: ${rule.pattern} occurred ${eventCount} times in ${rule.timeWindow / 1000} seconds`;
    
    console.warn(`ğŸš¨ ${alertMessage}`);
    
    // ì‹¬ê°í•œ ê²½ìš° ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡
    if (rule.alertLevel === 'critical') {
      this.notificationService.sendSystemAlert(alertMessage);
    }
  }
  
  private startCleanupTimer(): void {
    // 5ë¶„ë§ˆë‹¤ ì˜¤ë˜ëœ ì´ë²¤íŠ¸ ì •ë¦¬
    setInterval(() => {
      const now = Date.now();
      const maxAge = 60 * 60 * 1000; // 1ì‹œê°„
      
      for (const [key, events] of this.eventCounts.entries()) {
        const recentEvents = events.filter(timestamp => 
          now - timestamp <= maxAge
        );
        this.eventCounts.set(key, recentEvents);
      }
    }, 5 * 60 * 1000);
  }
}
```

---

## ğŸ“‹ ê³¼ì œ

### ğŸ“ ê¸°ë³¸ ê³¼ì œ
1. **ì¹´í…Œê³ ë¦¬ë³„ ë¡œê±°**: 3ê°œ ì´ìƒì˜ ì¹´í…Œê³ ë¦¬ë¥¼ ê°€ì§„ ë¡œê¹… ì‹œìŠ¤í…œ êµ¬í˜„
2. **ì „ì—­ ì—ëŸ¬ ì²˜ë¦¬**: ì²˜ë¦¬ë˜ì§€ ì•Šì€ ì˜ˆì™¸ì™€ Promise rejectionì„ ì²˜ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„
3. **ë¡œê·¸ íšŒì „**: íŒŒì¼ í¬ê¸° ì œí•œê³¼ ìë™ ì••ì¶• ê¸°ëŠ¥ì´ ìˆëŠ” ë¡œê·¸ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„

### ğŸš€ ì‘ìš© ê³¼ì œ
1. **êµ¬ì¡°í™”ëœ ë¡œê¹…**: JSON í˜•íƒœì˜ êµ¬ì¡°í™”ëœ ë¡œê·¸ì™€ ì»¨í…ìŠ¤íŠ¸ ì¶”ì  ì‹œìŠ¤í…œ êµ¬í˜„
2. **ì„±ëŠ¥ ìµœì í™”**: ë¹„ë™ê¸° ë°°ì¹˜ ì²˜ë¦¬ë¥¼ í†µí•œ ê³ ì„±ëŠ¥ ë¡œê¹… ì‹œìŠ¤í…œ êµ¬í˜„
3. **ë¡œê·¸ ë¶„ì„**: ë¡œê·¸ íŒ¨í„´ì„ ë¶„ì„í•˜ì—¬ ìë™ìœ¼ë¡œ ì•Œë¦¼ì„ ë³´ë‚´ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„

### ğŸ’ª ë„ì „ ê³¼ì œ
1. **ë¶„ì‚° ë¡œê¹…**: ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ì˜ ë¡œê·¸ë¥¼ ì¤‘ì•™ ì§‘ì¤‘í™”í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„
2. **ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ**: ì‹¤ì‹œê°„ ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë°ê³¼ ì‹œê°í™” ëŒ€ì‹œë³´ë“œ êµ¬í˜„
3. **ì§€ëŠ¥í˜• ì—ëŸ¬ ë¶„ë¥˜**: ë¨¸ì‹ ëŸ¬ë‹ì„ í™œìš©í•œ ì—ëŸ¬ íŒ¨í„´ ë¶„ë¥˜ ë° ìš°ì„ ìˆœìœ„ ì‹œìŠ¤í…œ êµ¬í˜„

---

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

### ğŸ“– í•µì‹¬ ë¬¸ì„œ
- [Winston Documentation](https://github.com/winstonjs/winston)
- [Node.js Error Handling Best Practices](https://nodejs.org/en/docs/guides/error-handling)
- [Structured Logging](https://stackify.com/what-is-structured-logging-and-why-developers-need-it/)

### ğŸ› ï¸ ì‹¤ìŠµ ë¦¬ì†ŒìŠ¤
- [Pino - Fast JSON Logger](https://github.com/pinojs/pino)
- [Sentry Error Tracking](https://sentry.io/)
- [ELK Stack for Log Management](https://www.elastic.co/elk-stack)

### ğŸ¯ í™•ì¥ í•™ìŠµ
- **ë¡œê·¸ ì§‘ê³„**: ELK Stackì„ í™œìš©í•œ ë¡œê·¸ ìˆ˜ì§‘ê³¼ ë¶„ì„
- **ë©”íŠ¸ë¦­ ìˆ˜ì§‘**: Prometheusì™€ Grafanaë¥¼ í™œìš©í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ ëª¨ë‹ˆí„°ë§
- **ë¶„ì‚° ì¶”ì **: OpenTelemetryë¥¼ í™œìš©í•œ ë¶„ì‚° ì‹œìŠ¤í…œ ì¶”ì 

---

## ğŸ’¡ í•µì‹¬ ì •ë¦¬

### âœ… í•™ìŠµ ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] Winston ê¸°ë°˜ ì¹´í…Œê³ ë¦¬ë³„ ë¡œê¹… ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì „ì—­ ì—ëŸ¬ ì²˜ë¦¬ì™€ í¬ë˜ì‹œ ë¦¬í¬íŒ… ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ë¡œê·¸ íšŒì „, ì••ì¶•, ì •ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] êµ¬ì¡°í™”ëœ ë¡œê¹…ê³¼ ì»¨í…ìŠ¤íŠ¸ ì¶”ì  êµ¬í˜„
- [ ] ì„±ëŠ¥ì„ ê³ ë ¤í•œ ë¹„ë™ê¸° ë¡œê¹… ì‹œìŠ¤í…œ êµ¬í˜„

### ğŸ¯ ë‹¤ìŒ ë‹¨ê³„ ë¯¸ë¦¬ë³´ê¸°
**15ì¼ì°¨**ì—ì„œëŠ” ì´ë ‡ê²Œ êµ¬ì¶•í•œ ëª¨ë“  ì‹œìŠ¤í…œì„ **íŒ¨í‚¤ì§•ê³¼ ë°°í¬**í•˜ì—¬, ì‹¤ì œ ì‚¬ìš©ìì—ê²Œ ë°°í¬ ê°€ëŠ¥í•œ ì™„ì„±ëœ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“œëŠ” ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.

---

*ğŸš€ í”„ë¡œë•ì…˜ ìˆ˜ì¤€ì˜ ì—ëŸ¬ ì²˜ë¦¬ì™€ ë¡œê¹… ì‹œìŠ¤í…œì„ ì™„ì „íˆ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤! ì´ì œ ìš´ì˜ í™˜ê²½ì—ì„œ ë°œìƒí•˜ëŠ” ëª¨ë“  ë¬¸ì œë¥¼ ì¶”ì í•˜ê³  í•´ê²°í•  ìˆ˜ ìˆëŠ” ê²¬ê³ í•œ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.*