# âš™ï¸ 13ì¼ì°¨: ì„¤ì • ê´€ë¦¬ì™€ ìë™ ì‹œì‘

> **í•™ìŠµ ëª©í‘œ**: ì‚¬ìš©ì ì„¤ì •ì˜ ì˜ì†í™”, ì‹œìŠ¤í…œ í†µí•©, UI ë™ê¸°í™” ë° Windows ìë™ ì‹œì‘ ê¸°ëŠ¥ êµ¬í˜„

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

### í•µì‹¬ ëª©í‘œ
- ì„¤ì • ë°ì´í„°ì˜ ì˜ì†í™”ì™€ ìºì‹± ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„
- Windows ì‹œìŠ¤í…œê³¼ì˜ í†µí•© (ìë™ ì‹œì‘ ê¸°ëŠ¥)
- ì‹¤ì‹œê°„ ì„¤ì • UIì™€ ë°±ì—”ë“œ ë™ê¸°í™”
- ì„¤ì • ê²€ì¦ê³¼ ê¸°ë³¸ê°’ ì²˜ë¦¬ ì‹œìŠ¤í…œ

### ì‹¤ë¬´ ì—­ëŸ‰
- ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµê³¼ í•˜ìœ„ í˜¸í™˜ì„± ë³´ì¥
- ì‹œìŠ¤í…œ ë ˆë²¨ í†µí•© (ë ˆì§€ìŠ¤íŠ¸ë¦¬, ì‹œì‘í”„ë¡œê·¸ë¨)
- ë°˜ì‘í˜• ì„¤ì • ì‹œìŠ¤í…œ ì„¤ê³„
- ì„¤ì • ë°±ì—…ê³¼ ë³µì› ë©”ì»¤ë‹ˆì¦˜

---

## ğŸ“š ì´ë¡  í•™ìŠµ

### 1. ì„¤ì • ê´€ë¦¬ì˜ í•µì‹¬ ì›ì¹™

#### ê³„ì¸µí™”ëœ ì„¤ì • êµ¬ì¡°
```typescript
// ì„¤ì • ìš°ì„ ìˆœìœ„: ì‚¬ìš©ì ì„¤ì • > ê¸°ë³¸ê°’ > ì‹œìŠ¤í…œ ê¸°ë³¸ê°’
interface SettingLayer {
  user: Record<string, any>;      // ì‚¬ìš©ìê°€ ì§ì ‘ ì„¤ì •í•œ ê°’
  default: Record<string, any>;   // ì• í”Œë¦¬ì¼€ì´ì…˜ ê¸°ë³¸ê°’
  system: Record<string, any>;    // ì‹œìŠ¤í…œì—ì„œ ê°•ì œí•˜ëŠ” ê°’
}

class LayeredSettingsManager {
  getValue(key: string): any {
    // ê³„ì¸µë³„ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ê°’ ë°˜í™˜
    return this.system[key] ?? this.user[key] ?? this.default[key];
  }
}
```

#### ë°˜ì‘í˜• ì„¤ì • ì‹œìŠ¤í…œ
```typescript
// ì„¤ì • ë³€ê²½ ì‹œ ì¦‰ì‹œ ë°˜ì˜ë˜ëŠ” ì‹œìŠ¤í…œ
class ReactiveSettings extends EventEmitter {
  private settings = new Map<string, any>();
  
  set(key: string, value: any): void {
    const oldValue = this.settings.get(key);
    this.settings.set(key, value);
    
    // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
    this.emit('setting-changed', { key, oldValue, newValue: value });
    this.emit(`setting-changed:${key}`, { oldValue, newValue: value });
  }
  
  // íŠ¹ì • ì„¤ì • ë³€ê²½ì„ êµ¬ë…
  onSettingChange(key: string, callback: (event: any) => void): void {
    this.on(`setting-changed:${key}`, callback);
  }
}
```

### 2. ì‹œìŠ¤í…œ í†µí•© íŒ¨í„´

#### Windows ìë™ ì‹œì‘ ë©”ì»¤ë‹ˆì¦˜
```typescript
// Windows ì‹œìŠ¤í…œê³¼ì˜ í†µí•©ì„ ìœ„í•œ API í™œìš©
import { app } from 'electron';

class WindowsIntegration {
  setAutoStart(enabled: boolean): void {
    app.setLoginItemSettings({
      openAtLogin: enabled,
      openAsHidden: true,           // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹œì‘
      name: 'My Application',
      path: process.execPath,       // ì‹¤í–‰ íŒŒì¼ ê²½ë¡œ
      args: ['--auto-start']        // ìë™ ì‹œì‘ í”Œë˜ê·¸
    });
  }
  
  getAutoStartStatus(): boolean {
    const settings = app.getLoginItemSettings();
    return settings.openAtLogin;
  }
}
```

#### ì„¤ì • ë™ê¸°í™” íŒ¨í„´
```typescript
// ì‹œìŠ¤í…œ ì„¤ì •ê³¼ ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì • ê°„ ë™ê¸°í™”
class SettingSyncManager {
  async syncSettings(): Promise<void> {
    const systemAutoStart = this.getSystemAutoStart();
    const appAutoStart = this.getAppAutoStart();
    
    if (systemAutoStart !== appAutoStart) {
      // ë¶ˆì¼ì¹˜ ë°œê²¬ ì‹œ ì•± ì„¤ì •ì„ ì‹œìŠ¤í…œì— ì ìš©
      await this.applyAppSettingToSystem('autoStart', appAutoStart);
    }
  }
}
```

---

## ğŸ” ì½”ë“œ ë¶„ì„

### 1. SettingsService í•µì‹¬ êµ¬ì¡°

#### ì„¤ì • ì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜
```typescript
export class SettingsService {
  private databaseManager: DatabaseManager;
  private settingsCache: Record<string, string> = {}; // ë©”ëª¨ë¦¬ ìºì‹œ
  private mainWindow: BrowserWindow | null = null;    // UI ì°¸ì¡°
  private trayService: TrayService | null = null;     // íŠ¸ë ˆì´ ì„œë¹„ìŠ¤ ì°¸ì¡°

  constructor(databaseManager: DatabaseManager, mainWindow?: BrowserWindow) {
    this.databaseManager = databaseManager;
    this.mainWindow = mainWindow || null;
  }

  async initialize(): Promise<void> {
    // ì„¤ì • ìºì‹œ ë¡œë“œ - ì„±ëŠ¥ ìµœì í™”
    this.settingsCache = await this.databaseManager.getAllSettings();
  }
}
```

#### ì„¤ì • ì½ê¸° ë° ê¸°ë³¸ê°’ ì²˜ë¦¬
```typescript
getSetting(key: SettingKey): string {
  // ìºì‹œì—ì„œ ë¨¼ì € ì¡°íšŒ, ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ë°˜í™˜
  return this.settingsCache[key] || this.getDefaultValue(key);
}

private getDefaultValue(key: SettingKey): string {
  const defaults: Record<SettingKey, string> = {
    checkInterval: '30',                    // 30ì´ˆ ì²´í¬ ê°„ê²©
    autoStart: 'false',                     // ìë™ ì‹œì‘ ë¹„í™œì„±í™”
    minimizeToTray: 'true',                 // íŠ¸ë ˆì´ë¡œ ìµœì†Œí™” í™œì„±í™”
    showDesktopNotifications: 'true',       // ë°ìŠ¤í¬í†± ì•Œë¦¼ í™œì„±í™”
    cacheCleanupInterval: '3600',           // 1ì‹œê°„ë§ˆë‹¤ ìºì‹œ ì •ë¦¬
    theme: 'dark',                          // ë‹¤í¬ í…Œë§ˆ ê¸°ë³¸ê°’
    needNaverLogin: 'true',                 // ë„¤ì´ë²„ ë¡œê·¸ì¸ í•„ìš”
    needWeverseLogin: 'true',               // ìœ„ë²„ìŠ¤ ë¡œê·¸ì¸ í•„ìš”
    newStreamerFilterHours: '24'            // 24ì‹œê°„ í•„í„°
  };

  return defaults[key] || '';
}
```

### 2. ì‹¤ì‹œê°„ ì„¤ì • ì—…ë°ì´íŠ¸ ì‹œìŠ¤í…œ

#### ì„¤ì • ë³€ê²½ê³¼ UI ë™ê¸°í™”
```typescript
async updateSetting(key: SettingKey, value: any): Promise<void> {
  const stringValue = String(value);
  
  // 1. ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
  await this.databaseManager.setSetting(key, stringValue);
  
  // 2. ë©”ëª¨ë¦¬ ìºì‹œ ì—…ë°ì´íŠ¸
  this.settingsCache[key] = stringValue;
  
  // 3. íŠ¹ë³„í•œ ì„¤ì • ì²˜ë¦¬ (Windows ìë™ ì‹œì‘)
  if (key === 'autoStart') {
    await this.updateAutoStart(value === true || value === 'true');
  }
  
  // 4. ëª¨ë“  ì„¤ì • ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  const allSettings = await this.getAllSettings();
  
  // 5. UIì— ì„¤ì • ë³€ê²½ ì•Œë¦¼ (IPCë¥¼ í†µí•œ ì‹¤ì‹œê°„ ë™ê¸°í™”)
  if (this.mainWindow && !this.mainWindow.isDestroyed()) {
    this.mainWindow.webContents.send('settings-updated', allSettings);
    console.log(`ğŸ“¡ Setting updated: ${key} = ${stringValue}`);
  }
  
  // 6. íŠ¸ë ˆì´ ë©”ë‰´ ì—…ë°ì´íŠ¸
  if (this.trayService) {
    this.trayService.updateWithSettings(allSettings);
    console.log(`ğŸ–±ï¸ Tray menu updated with settings`);
  }
}
```

#### íƒ€ì… ì•ˆì „í•œ ì„¤ì • ì ‘ê·¼ì
```typescript
// ì‹¤ì‹œê°„ ì„¤ì • ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ í—¬í¼ ë©”ì„œë“œë“¤
getCheckInterval(): number {
  return parseInt(this.getSetting('checkInterval'));
}

getAutoStart(): boolean {
  return this.getSetting('autoStart') === 'true';
}

getMinimizeToTray(): boolean {
  return this.getSetting('minimizeToTray') === 'true';
}

getShowDesktopNotifications(): boolean {
  return this.getSetting('showDesktopNotifications') === 'true';
}

getCacheCleanupInterval(): number {
  return parseInt(this.getSetting('cacheCleanupInterval'));
}

getTheme(): string {
  return this.getSetting('theme');
}

getNeedNaverLogin(): boolean {
  return this.getSetting('needNaverLogin') === 'true';
}

getNeedWeverseLogin(): boolean {
  return this.getSetting('needWeverseLogin') === 'true';
}
```

### 3. Windows ìë™ ì‹œì‘ êµ¬í˜„

#### ìë™ ì‹œì‘ ì„¤ì • ì—…ë°ì´íŠ¸
```typescript
/**
 * Windows ìë™ ì‹œì‘ ì„¤ì • ì—…ë°ì´íŠ¸
 */
private async updateAutoStart(enable: boolean): Promise<void> {
  try {
    console.log(`ğŸš€ Setting Windows auto-start: ${enable}`);
    
    // ê°œë°œ í™˜ê²½ì—ì„œëŠ” ìë™ ì‹œì‘ ê¸°ëŠ¥ì„ ê±´ë„ˆëœ€
    if (process.env.NODE_ENV === 'development') {
      console.log('âš ï¸ Skipping auto-start in development mode');
      return;
    }
    
    // í˜„ì¬ ìë™ ì‹œì‘ ìƒíƒœ í™•ì¸
    const currentSettings = app.getLoginItemSettings();
    console.log('Current login item settings:', currentSettings);
    
    if (enable) {
      // ìë™ ì‹œì‘ í™œì„±í™”
      const appPath = process.execPath;
      console.log(`App path: ${appPath}`);
      
      app.setLoginItemSettings({
        openAtLogin: true,
        openAsHidden: true,           // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹œì‘
        name: 'Streamer Alarm System',
        path: appPath,                // ì‹¤í–‰ íŒŒì¼ ê²½ë¡œ ëª…ì‹œ
        args: ['--auto-start'],       // ìë™ ì‹œì‘ í”Œë˜ê·¸ ì¶”ê°€
      });
      console.log('âœ… Auto-start enabled');
    } else {
      // ìë™ ì‹œì‘ ë¹„í™œì„±í™”
      app.setLoginItemSettings({
        openAtLogin: false
      });
      console.log('âŒ Auto-start disabled');
    }
    
    // ì„¤ì • í›„ ìƒíƒœ í™•ì¸ ë° ê²€ì¦
    const updatedSettings = app.getLoginItemSettings();
    console.log('Updated login item settings:', updatedSettings);
    
    // Windowsì—ì„œëŠ” ì¶”ê°€ ê²€ì¦
    if (process.platform === 'win32') {
      const finalCheck = app.getLoginItemSettings();
      if (finalCheck.openAtLogin !== enable) {
        console.warn(`âš ï¸ Auto-start setting mismatch: expected ${enable}, got ${finalCheck.openAtLogin}`);
      }
    }
    
  } catch (error) {
    console.error('âŒ Failed to update auto-start setting:', error);
    throw error;
  }
}
```

#### ìë™ ì‹œì‘ ìƒíƒœ í™•ì¸ ë° ë™ê¸°í™”
```typescript
/**
 * í˜„ì¬ Windows ìë™ ì‹œì‘ ìƒíƒœ í™•ì¸
 */
isAutoStartEnabled(): boolean {
  try {
    // ê°œë°œ í™˜ê²½ì—ì„œëŠ” DB ì„¤ì •ë§Œ ë°˜í™˜
    if (process.env.NODE_ENV === 'development') {
      return this.getAutoStart();
    }
    
    const settings = app.getLoginItemSettings();
    console.log('ğŸ” Current login item settings:', settings);
    return settings.openAtLogin;
  } catch (error) {
    console.error('Failed to get auto-start status:', error);
    return false;
  }
}

/**
 * ì•± ì‹œì‘ ì‹œ ìë™ ì‹œì‘ ì„¤ì • ë™ê¸°í™”
 */
async syncAutoStartSetting(): Promise<void> {
  try {
    const systemAutoStart = this.isAutoStartEnabled();  // ì‹œìŠ¤í…œ ì„¤ì •
    const dbAutoStart = this.getAutoStart();            // DB ì„¤ì •
    
    console.log(`ğŸ”„ Syncing auto-start: system=${systemAutoStart}, db=${dbAutoStart}`);
    
    // ì‹œìŠ¤í…œ ì„¤ì •ê³¼ DB ì„¤ì •ì´ ë‹¤ë¥´ë©´ DB ì„¤ì •ì„ ë”°ë¦„
    if (systemAutoStart !== dbAutoStart) {
      console.log(`Syncing auto-start from DB setting: ${dbAutoStart}`);
      await this.updateAutoStart(dbAutoStart);
    }
  } catch (error) {
    console.error('Failed to sync auto-start setting:', error);
  }
}
```

### 4. ì„¤ì • ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œìŠ¤í…œ

#### í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ ë§ˆì´ê·¸ë ˆì´ì…˜
```typescript
async migrateSettings(settingsData: Record<string, any>): Promise<void> {
  // ê¸°ì¡´ ì„¤ì •ì´ ìˆëŠ”ì§€ í™•ì¸
  const existingSettings = await this.databaseManager.getAllSettings();
  
  if (Object.keys(existingSettings).length > 7) { // ê¸°ë³¸ ì„¤ì •ë³´ë‹¤ ë§ìœ¼ë©´ ì´ë¯¸ ë§ˆì´ê·¸ë ˆì´ì…˜ë¨
    console.log('Settings already migrated, skipping');
    return;
  }

  // ì„¤ì • ë§¤í•‘ (ì´ì „ í‚¤ -> ìƒˆë¡œìš´ í‚¤)
  const settingMapping: Record<string, string> = {
    'check_interval': 'checkInterval',
    'start_with_windows': 'autoStart',
    'minimize_to_tray': 'minimizeToTray',
    'show_notifications': 'showDesktopNotifications',
    'cache_cleanup_interval': 'cacheCleanupInterval',
    'theme': 'theme',
    'need_naver_login': 'needNaverLogin'
  };

  // ê° ì„¤ì •ì„ ìƒˆë¡œìš´ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
  for (const [oldKey, newKey] of Object.entries(settingMapping)) {
    if (settingsData[oldKey] !== undefined) {
      await this.updateSetting(newKey as SettingKey, settingsData[oldKey]);
    }
  }

  console.log('Settings migration completed');
}
```

---

## ğŸ› ï¸ ì‹¤ìŠµ ì˜ˆì œ

### 1. ê¸°ë³¸ ì„¤ì • ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„

#### Step 1: ì„¤ì • ì €ì¥ì†Œ êµ¬í˜„
```typescript
// src/main/services/ConfigStore.ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { app } from 'electron';

interface ConfigSchema {
  version: string;
  settings: Record<string, any>;
  metadata: {
    createdAt: string;
    updatedAt: string;
  };
}

class ConfigStore {
  private configPath: string;
  private config: ConfigSchema;
  
  constructor() {
    const userDataPath = app.getPath('userData');
    this.configPath = path.join(userDataPath, 'app-config.json');
    
    this.config = {
      version: '1.0.0',
      settings: {},
      metadata: {
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
    };
  }
  
  async initialize(): Promise<void> {
    try {
      // ì„¤ì • íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ ë¡œë“œ
      const data = await fs.readFile(this.configPath, 'utf8');
      this.config = JSON.parse(data);
      console.log('Config loaded from file');
    } catch (error) {
      // íŒŒì¼ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ì´ˆê¸°í™”
      console.log('Config file not found, using defaults');
      await this.save();
    }
  }
  
  get<T>(key: string, defaultValue?: T): T {
    return this.config.settings[key] ?? defaultValue;
  }
  
  async set(key: string, value: any): Promise<void> {
    this.config.settings[key] = value;
    this.config.metadata.updatedAt = new Date().toISOString();
    await this.save();
  }
  
  async setMultiple(settings: Record<string, any>): Promise<void> {
    Object.assign(this.config.settings, settings);
    this.config.metadata.updatedAt = new Date().toISOString();
    await this.save();
  }
  
  getAll(): Record<string, any> {
    return { ...this.config.settings };
  }
  
  async reset(): Promise<void> {
    this.config.settings = {};
    this.config.metadata.updatedAt = new Date().toISOString();
    await this.save();
  }
  
  private async save(): Promise<void> {
    try {
      const data = JSON.stringify(this.config, null, 2);
      await fs.writeFile(this.configPath, data, 'utf8');
    } catch (error) {
      console.error('Failed to save config:', error);
      throw error;
    }
  }
}
```

#### Step 2: ë°˜ì‘í˜• ì„¤ì • ë§¤ë‹ˆì €
```typescript
// src/main/services/ReactiveSettingsManager.ts
import { EventEmitter } from 'events';

class ReactiveSettingsManager extends EventEmitter {
  private configStore: ConfigStore;
  private validators: Map<string, (value: any) => boolean> = new Map();
  private transformers: Map<string, (value: any) => any> = new Map();
  
  constructor(configStore: ConfigStore) {
    super();
    this.configStore = configStore;
    
    this.setupValidators();
    this.setupTransformers();
  }
  
  private setupValidators(): void {
    // ì²´í¬ ê°„ê²©ì€ 5ì´ˆ ì´ìƒì´ì–´ì•¼ í•¨
    this.validators.set('checkInterval', (value) => {
      const num = parseInt(value);
      return !isNaN(num) && num >= 5;
    });
    
    // í…Œë§ˆëŠ” 'light' ë˜ëŠ” 'dark'ë§Œ í—ˆìš©
    this.validators.set('theme', (value) => {
      return ['light', 'dark'].includes(value);
    });
  }
  
  private setupTransformers(): void {
    // ìˆ«ì ê°’ì€ ì •ìˆ˜ë¡œ ë³€í™˜
    this.transformers.set('checkInterval', (value) => parseInt(value));
    this.transformers.set('cacheCleanupInterval', (value) => parseInt(value));
    
    // ë¶ˆë¦° ê°’ì€ ë¬¸ìì—´ì—ì„œ ë³€í™˜
    this.transformers.set('autoStart', (value) => {
      if (typeof value === 'boolean') return value;
      return value === 'true' || value === true;
    });
  }
  
  async get(key: string, defaultValue?: any): Promise<any> {
    const value = this.configStore.get(key, defaultValue);
    
    // ë³€í™˜ê¸°ê°€ ìˆìœ¼ë©´ ì ìš©
    if (this.transformers.has(key)) {
      return this.transformers.get(key)!(value);
    }
    
    return value;
  }
  
  async set(key: string, value: any): Promise<void> {
    // ê²€ì¦
    if (this.validators.has(key)) {
      if (!this.validators.get(key)!(value)) {
        throw new Error(`Invalid value for setting '${key}': ${value}`);
      }
    }
    
    // ì´ì „ ê°’ ê°€ì ¸ì˜¤ê¸°
    const oldValue = await this.get(key);
    
    // ê°’ ì €ì¥
    await this.configStore.set(key, value);
    
    // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
    this.emit('setting-changed', { key, oldValue, newValue: value });
    this.emit(`setting-changed:${key}`, { oldValue, newValue: value });
    
    console.log(`Setting changed: ${key} = ${value} (was: ${oldValue})`);
  }
  
  async setMultiple(settings: Record<string, any>): Promise<void> {
    const changes: Array<{ key: string; oldValue: any; newValue: any }> = [];
    
    // ëª¨ë“  ë³€ê²½ì‚¬í•­ ê²€ì¦
    for (const [key, value] of Object.entries(settings)) {
      if (this.validators.has(key) && !this.validators.get(key)!(value)) {
        throw new Error(`Invalid value for setting '${key}': ${value}`);
      }
      
      const oldValue = await this.get(key);
      changes.push({ key, oldValue, newValue: value });
    }
    
    // ì¼ê´„ ì €ì¥
    await this.configStore.setMultiple(settings);
    
    // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
    for (const change of changes) {
      this.emit('setting-changed', change);
      this.emit(`setting-changed:${change.key}`, {
        oldValue: change.oldValue,
        newValue: change.newValue
      });
    }
    
    console.log(`Multiple settings changed: ${Object.keys(settings).join(', ')}`);
  }
  
  // íŠ¹ì • ì„¤ì • ë³€ê²½ì„ êµ¬ë…
  onSettingChange(key: string, callback: (event: { oldValue: any; newValue: any }) => void): void {
    this.on(`setting-changed:${key}`, callback);
  }
  
  // ëª¨ë“  ì„¤ì • ë³€ê²½ì„ êµ¬ë…
  onAnySettingChange(callback: (event: { key: string; oldValue: any; newValue: any }) => void): void {
    this.on('setting-changed', callback);
  }
}
```

### 2. ì‹œìŠ¤í…œ í†µí•© ê¸°ëŠ¥ êµ¬í˜„

#### Step 1: í”Œë«í¼ë³„ ìë™ ì‹œì‘ ê´€ë¦¬
```typescript
// src/main/services/SystemIntegration.ts
import { app } from 'electron';
import * as os from 'os';

class SystemIntegration {
  private appName: string;
  private appPath: string;
  
  constructor(appName: string) {
    this.appName = appName;
    this.appPath = process.execPath;
  }
  
  async setAutoStart(enabled: boolean): Promise<void> {
    const platform = os.platform();
    
    switch (platform) {
      case 'win32':
        await this.setWindowsAutoStart(enabled);
        break;
      case 'darwin':
        await this.setMacAutoStart(enabled);
        break;
      case 'linux':
        await this.setLinuxAutoStart(enabled);
        break;
      default:
        throw new Error(`Unsupported platform: ${platform}`);
    }
  }
  
  private async setWindowsAutoStart(enabled: boolean): Promise<void> {
    try {
      console.log(`Setting Windows auto-start: ${enabled}`);
      
      app.setLoginItemSettings({
        openAtLogin: enabled,
        openAsHidden: true,
        name: this.appName,
        path: this.appPath,
        args: enabled ? ['--auto-start'] : []
      });
      
      // ì„¤ì • ê²€ì¦
      const settings = app.getLoginItemSettings();
      if (settings.openAtLogin !== enabled) {
        throw new Error('Failed to set auto-start setting');
      }
      
      console.log(`Windows auto-start ${enabled ? 'enabled' : 'disabled'}`);
    } catch (error) {
      console.error('Failed to set Windows auto-start:', error);
      throw error;
    }
  }
  
  private async setMacAutoStart(enabled: boolean): Promise<void> {
    // macOSëŠ” Electronì˜ ê¸°ë³¸ API ì‚¬ìš©
    app.setLoginItemSettings({
      openAtLogin: enabled,
      openAsHidden: true
    });
    
    console.log(`macOS auto-start ${enabled ? 'enabled' : 'disabled'}`);
  }
  
  private async setLinuxAutoStart(enabled: boolean): Promise<void> {
    // LinuxëŠ” .desktop íŒŒì¼ì„ autostart ë””ë ‰í† ë¦¬ì— ìƒì„±/ì‚­ì œ
    const fs = require('fs/promises');
    const path = require('path');
    const os = require('os');
    
    const autostartDir = path.join(os.homedir(), '.config', 'autostart');
    const desktopFile = path.join(autostartDir, `${this.appName.toLowerCase().replace(/\s+/g, '-')}.desktop`);
    
    if (enabled) {
      // .desktop íŒŒì¼ ìƒì„±
      const desktopContent = [
        '[Desktop Entry]',
        'Type=Application',
        `Name=${this.appName}`,
        `Exec=${this.appPath} --auto-start`,
        'Hidden=false',
        'NoDisplay=false',
        'X-GNOME-Autostart-enabled=true'
      ].join('\n');
      
      await fs.mkdir(autostartDir, { recursive: true });
      await fs.writeFile(desktopFile, desktopContent);
    } else {
      // .desktop íŒŒì¼ ì‚­ì œ
      try {
        await fs.unlink(desktopFile);
      } catch (error) {
        // íŒŒì¼ì´ ì—†ì–´ë„ ë¬´ì‹œ
        if (error.code !== 'ENOENT') {
          throw error;
        }
      }
    }
    
    console.log(`Linux auto-start ${enabled ? 'enabled' : 'disabled'}`);
  }
  
  async isAutoStartEnabled(): Promise<boolean> {
    const platform = os.platform();
    
    switch (platform) {
      case 'win32':
      case 'darwin':
        const settings = app.getLoginItemSettings();
        return settings.openAtLogin;
        
      case 'linux':
        return await this.isLinuxAutoStartEnabled();
        
      default:
        return false;
    }
  }
  
  private async isLinuxAutoStartEnabled(): Promise<boolean> {
    try {
      const fs = require('fs/promises');
      const path = require('path');
      const os = require('os');
      
      const desktopFile = path.join(
        os.homedir(),
        '.config',
        'autostart',
        `${this.appName.toLowerCase().replace(/\s+/g, '-')}.desktop`
      );
      
      await fs.access(desktopFile);
      return true;
    } catch {
      return false;
    }
  }
}
```

#### Step 2: ì„¤ì •ê³¼ ì‹œìŠ¤í…œ í†µí•© ì—°ê²°
```typescript
// src/main/services/IntegratedSettingsService.ts
class IntegratedSettingsService extends ReactiveSettingsManager {
  private systemIntegration: SystemIntegration;
  
  constructor(configStore: ConfigStore, systemIntegration: SystemIntegration) {
    super(configStore);
    this.systemIntegration = systemIntegration;
    
    this.setupSystemIntegration();
  }
  
  private setupSystemIntegration(): void {
    // ìë™ ì‹œì‘ ì„¤ì •ì´ ë³€ê²½ë˜ë©´ ì‹œìŠ¤í…œì— ë°˜ì˜
    this.onSettingChange('autoStart', async ({ newValue }) => {
      try {
        await this.systemIntegration.setAutoStart(newValue);
        console.log(`System auto-start updated: ${newValue}`);
      } catch (error) {
        console.error('Failed to update system auto-start:', error);
        // ì‹¤íŒ¨ ì‹œ ì„¤ì •ì„ ì›ë˜ëŒ€ë¡œ ë˜ëŒë¦¼
        const currentSystemState = await this.systemIntegration.isAutoStartEnabled();
        await this.set('autoStart', currentSystemState);
      }
    });
  }
  
  async syncWithSystem(): Promise<void> {
    try {
      const systemAutoStart = await this.systemIntegration.isAutoStartEnabled();
      const settingAutoStart = await this.get('autoStart', false);
      
      console.log(`Syncing auto-start: system=${systemAutoStart}, setting=${settingAutoStart}`);
      
      if (systemAutoStart !== settingAutoStart) {
        // ì„¤ì •ì„ ì‹œìŠ¤í…œ ìƒíƒœì— ë§ì¶¤
        await this.set('autoStart', systemAutoStart);
        console.log(`Auto-start synced to system state: ${systemAutoStart}`);
      }
    } catch (error) {
      console.error('Failed to sync with system:', error);
    }
  }
}
```

### 3. UIì™€ ì‹¤ì‹œê°„ ë™ê¸°í™”

#### Step 1: ì„¤ì • ë³€ê²½ ë¸Œë¡œë“œìºìŠ¤í„°
```typescript
// src/main/services/SettingsBroadcaster.ts
import { BrowserWindow, webContents } from 'electron';

class SettingsBroadcaster {
  private settingsService: IntegratedSettingsService;
  private windows: Set<BrowserWindow> = new Set();
  
  constructor(settingsService: IntegratedSettingsService) {
    this.settingsService = settingsService;
    
    this.setupBroadcasting();
  }
  
  registerWindow(window: BrowserWindow): void {
    this.windows.add(window);
    
    // ìœˆë„ìš°ê°€ ë‹«íˆë©´ ë“±ë¡ í•´ì œ
    window.on('closed', () => {
      this.windows.delete(window);
    });
    
    // ìƒˆ ìœˆë„ìš°ì— í˜„ì¬ ì„¤ì • ì „ì†¡
    this.sendSettingsToWindow(window);
  }
  
  private setupBroadcasting(): void {
    // ëª¨ë“  ì„¤ì • ë³€ê²½ì„ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    this.settingsService.onAnySettingChange((event) => {
      this.broadcastSettingChange(event.key, event.newValue);
    });
  }
  
  private async sendSettingsToWindow(window: BrowserWindow): Promise<void> {
    if (!window || window.isDestroyed()) return;
    
    try {
      const allSettings = await this.getAllSettings();
      window.webContents.send('settings-updated', allSettings);
    } catch (error) {
      console.error('Failed to send settings to window:', error);
    }
  }
  
  private broadcastSettingChange(key: string, value: any): void {
    const validWindows = Array.from(this.windows).filter(w => !w.isDestroyed());
    
    validWindows.forEach(window => {
      try {
        window.webContents.send('setting-changed', { key, value });
      } catch (error) {
        console.error('Failed to broadcast setting change:', error);
      }
    });
    
    console.log(`Broadcasted setting change: ${key} = ${value} to ${validWindows.length} windows`);
  }
  
  async broadcastAllSettings(): Promise<void> {
    const allSettings = await this.getAllSettings();
    
    const validWindows = Array.from(this.windows).filter(w => !w.isDestroyed());
    validWindows.forEach(window => {
      try {
        window.webContents.send('settings-updated', allSettings);
      } catch (error) {
        console.error('Failed to broadcast all settings:', error);
      }
    });
  }
  
  private async getAllSettings(): Promise<Record<string, any>> {
    // ëª¨ë“  ì„¤ì •ì„ íƒ€ì…ì— ë§ê²Œ ë³€í™˜í•˜ì—¬ ë°˜í™˜
    return {
      checkInterval: await this.settingsService.get('checkInterval', 30),
      autoStart: await this.settingsService.get('autoStart', false),
      minimizeToTray: await this.settingsService.get('minimizeToTray', true),
      showDesktopNotifications: await this.settingsService.get('showDesktopNotifications', true),
      cacheCleanupInterval: await this.settingsService.get('cacheCleanupInterval', 3600),
      theme: await this.settingsService.get('theme', 'dark'),
      needNaverLogin: await this.settingsService.get('needNaverLogin', true),
      needWeverseLogin: await this.settingsService.get('needWeverseLogin', true),
    };
  }
}
```

#### Step 2: ë©”ì¸ í”„ë¡œì„¸ìŠ¤ í†µí•©
```typescript
// src/main/main.ts
class Application {
  private configStore: ConfigStore;
  private systemIntegration: SystemIntegration;
  private settingsService: IntegratedSettingsService;
  private settingsBroadcaster: SettingsBroadcaster;
  
  async initialize(): Promise<void> {
    // ì„¤ì • ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    this.configStore = new ConfigStore();
    await this.configStore.initialize();
    
    this.systemIntegration = new SystemIntegration('My Application');
    this.settingsService = new IntegratedSettingsService(
      this.configStore,
      this.systemIntegration
    );
    
    this.settingsBroadcaster = new SettingsBroadcaster(this.settingsService);
    
    // ì‹œìŠ¤í…œê³¼ ì„¤ì • ë™ê¸°í™”
    await this.settingsService.syncWithSystem();
    
    console.log('Settings system initialized');
  }
  
  createWindow(): BrowserWindow {
    const window = new BrowserWindow({
      // ìœˆë„ìš° ì„¤ì •...
    });
    
    // ì„¤ì • ë¸Œë¡œë“œìºìŠ¤í„°ì— ìœˆë„ìš° ë“±ë¡
    this.settingsBroadcaster.registerWindow(window);
    
    return window;
  }
}
```

---

## ğŸ“‹ ê³¼ì œ

### ğŸ“ ê¸°ë³¸ ê³¼ì œ
1. **ì„¤ì • ì €ì¥ì†Œ**: JSON íŒŒì¼ ê¸°ë°˜ ì„¤ì • ì €ì¥ì†Œ êµ¬í˜„
2. **ìë™ ì‹œì‘ ê¸°ëŠ¥**: Windows ìë™ ì‹œì‘ ê¸°ëŠ¥ êµ¬í˜„
3. **ì‹¤ì‹œê°„ ë™ê¸°í™”**: ì„¤ì • ë³€ê²½ ì‹œ UI ì¦‰ì‹œ ì—…ë°ì´íŠ¸ êµ¬í˜„

### ğŸš€ ì‘ìš© ê³¼ì œ
1. **ì„¤ì • ê²€ì¦**: ì…ë ¥ê°’ ê²€ì¦ê³¼ íƒ€ì… ë³€í™˜ ì‹œìŠ¤í…œ êµ¬í˜„
2. **ì„¤ì • ë°±ì—…**: ì„¤ì • ë°±ì—…ê³¼ ë³µì› ê¸°ëŠ¥ êµ¬í˜„
3. **ë‹¤êµ­ì–´ ì„¤ì •**: ì–¸ì–´ë³„ ì„¤ì • ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„

### ğŸ’ª ë„ì „ ê³¼ì œ
1. **í´ë¼ìš°ë“œ ë™ê¸°í™”**: ì—¬ëŸ¬ ê¸°ê¸° ê°„ ì„¤ì • ë™ê¸°í™” ì‹œìŠ¤í…œ êµ¬í˜„
2. **ì„¤ì • í”„ë¡œíŒŒì¼**: ì‚¬ìš©ìë³„ ì„¤ì • í”„ë¡œíŒŒì¼ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„
3. **ìŠ¤í‚¤ë§ˆ ë§ˆì´ê·¸ë ˆì´ì…˜**: ì„¤ì • ìŠ¤í‚¤ë§ˆ ë²„ì „ ê´€ë¦¬ì™€ ìë™ ë§ˆì´ê·¸ë ˆì´ì…˜ êµ¬í˜„

---

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

### ğŸ“– í•µì‹¬ ë¬¸ì„œ
- [Electron App APIs](https://www.electronjs.org/docs/latest/api/app)
- [Windows Registry for Auto-start](https://docs.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys)
- [Configuration Management Patterns](https://martinfowler.com/articles/injection.html)

### ğŸ› ï¸ ì‹¤ìŠµ ë¦¬ì†ŒìŠ¤
- [Electron Settings Management](https://github.com/nathanbuchar/electron-settings)
- [Cross-platform Auto-start](https://github.com/Teamwork/node-auto-launch)
- [Configuration Validation](https://github.com/sideway/joi)

### ğŸ¯ í™•ì¥ í•™ìŠµ
- **ì„¤ì • ì•”í˜¸í™”**: ë¯¼ê°í•œ ì„¤ì •ì˜ ì•”í˜¸í™” ì €ì¥
- **ì„¤ì • ê°ì‚¬**: ì„¤ì • ë³€ê²½ ì´ë ¥ ì¶”ì ê³¼ ë¡¤ë°±
- **ì›ê²© ì„¤ì •**: ì„œë²„ì—ì„œ ì„¤ì •ì„ í‘¸ì‹œí•˜ëŠ” ì‹œìŠ¤í…œ

---

## ğŸ’¡ í•µì‹¬ ì •ë¦¬

### âœ… í•™ìŠµ ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ê³„ì¸µí™”ëœ ì„¤ì • ì‹œìŠ¤í…œì˜ ì„¤ê³„ì™€ êµ¬í˜„
- [ ] Windows ì‹œìŠ¤í…œê³¼ì˜ í†µí•© (ìë™ ì‹œì‘) êµ¬í˜„
- [ ] ì‹¤ì‹œê°„ ì„¤ì • ë™ê¸°í™” ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì„¤ì • ê²€ì¦ê³¼ ë³€í™˜ ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„
- [ ] ë§ˆì´ê·¸ë ˆì´ì…˜ê³¼ í•˜ìœ„ í˜¸í™˜ì„± ë³´ì¥

### ğŸ¯ ë‹¤ìŒ ë‹¨ê³„ ë¯¸ë¦¬ë³´ê¸°
**14ì¼ì°¨**ì—ì„œëŠ” ì´ëŸ¬í•œ ì„¤ì • ì‹œìŠ¤í…œì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” **ì—ëŸ¬ ì²˜ë¦¬ì™€ ë¡œê¹…** ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ì—¬, ìš´ì˜ í™˜ê²½ì—ì„œ ë¬¸ì œë¥¼ ë¹ ë¥´ê²Œ ì§„ë‹¨í•˜ê³  í•´ê²°í•  ìˆ˜ ìˆëŠ” ì‹œìŠ¤í…œì„ ì™„ì„±í•©ë‹ˆë‹¤.

---

*ğŸš€ í”„ë¡œë•ì…˜ ìˆ˜ì¤€ì˜ ì„¤ì • ê´€ë¦¬ ì‹œìŠ¤í…œì„ ì™„ì „íˆ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤! ì´ì œ ì‚¬ìš©ì ì¹œí™”ì ì´ê³  ì‹œìŠ¤í…œê³¼ ì™„ë²½íˆ í†µí•©ëœ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.*