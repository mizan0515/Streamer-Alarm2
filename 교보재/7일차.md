# 7ì¼ì°¨: 1ì£¼ì°¨ ì¢…í•© ì‹¤ìŠµ - Simple Task Manager êµ¬í˜„

## í•™ìŠµ ëª©í‘œ
- 1ì£¼ì°¨ í•™ìŠµ ë‚´ìš©ì„ í†µí•©í•˜ì—¬ ì™„ì „í•œ Electron ì•±ì„ êµ¬í˜„í•œë‹¤
- Main-Renderer-Preload ì•„í‚¤í…ì²˜ë¥¼ ì‹¤ì œë¡œ êµ¬í˜„í•œë‹¤  
- IPC í†µì‹ ê³¼ Context Bridge íŒ¨í„´ì„ í™œìš©í•œë‹¤
- ì‹¤ë¬´ ìˆ˜ì¤€ì˜ ì½”ë“œ êµ¬ì¡°ì™€ íŒ¨í„´ì„ ì ìš©í•œë‹¤

## í”„ë¡œì íŠ¸ ê°œìš”

### ğŸ¯ ë¯¸ë‹ˆ í”„ë¡œì íŠ¸: "Simple Task Manager"

**ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­:**
- âœ… ì‘ì—…(Task) ì¶”ê°€, ìˆ˜ì •, ì‚­ì œ
- âœ… ì‘ì—… ì™„ë£Œ ìƒíƒœ í† ê¸€
- âœ… ë°ì´í„° ì˜ì†ì„± (JSON íŒŒì¼ ì €ì¥)
- âœ… ì‹œìŠ¤í…œ íŠ¸ë ˆì´ í†µí•©
- âœ… í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì§€ì›
- âœ… ì•ˆì „í•œ IPC í†µì‹ 

**í•™ìŠµ ëª©í‘œ:**
- Electron í”„ë¡œì íŠ¸ ì´ˆê¸° ì„¤ì •
- ë³´ì•ˆì„ ê³ ë ¤í•œ ì•„í‚¤í…ì²˜ êµ¬í˜„
- ì‹¤ë¬´ ê°œë°œ ì›Œí¬í”Œë¡œìš° ì²´í—˜

## ë‹¨ê³„ë³„ êµ¬í˜„ ê°€ì´ë“œ

### Step 1: í”„ë¡œì íŠ¸ ì´ˆê¸° ì„¤ì •

#### 1.1 í”„ë¡œì íŠ¸ ìƒì„± ë° ì˜ì¡´ì„± ì„¤ì¹˜
```bash
# í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ìƒì„±
mkdir simple-task-manager
cd simple-task-manager

# package.json ì´ˆê¸°í™”
npm init -y

# ì˜ì¡´ì„± ì„¤ì¹˜
npm install electron react react-dom
npm install -D typescript @types/node @types/react @types/react-dom
npm install -D webpack webpack-cli webpack-dev-server
npm install -D ts-loader html-webpack-plugin css-loader style-loader
npm install -D concurrently cross-env
```

#### 1.2 TypeScript ì„¤ì •
```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "es2020",
    "lib": ["dom", "dom.iterable", "es2020"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "./",
    "paths": {
      "@/*": ["src/*"],
      "@shared/*": ["src/shared/*"]
    }
  },
  "include": [
    "src/**/*"
  ]
}
```

#### 1.3 í”„ë¡œì íŠ¸ êµ¬ì¡° ìƒì„±
```
simple-task-manager/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”œâ”€â”€ main.ts
â”‚   â”‚   â””â”€â”€ preload.ts
â”‚   â”œâ”€â”€ renderer/
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ index.tsx
â”‚   â”‚   â”œâ”€â”€ App.tsx
â”‚   â”‚   â””â”€â”€ components/
â”‚   â””â”€â”€ shared/
â”‚       â””â”€â”€ types.ts
â”œâ”€â”€ webpack.main.config.js
â”œâ”€â”€ webpack.renderer.config.js
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

### Step 2: íƒ€ì… ì •ì˜ êµ¬í˜„

```typescript
// src/shared/types.ts
export interface Task {
  id: string;
  title: string;
  description: string;
  completed: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface IpcEvents {
  'get-tasks': () => Task[];
  'add-task': (task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>) => Task;
  'update-task': (task: Task) => Task;
  'delete-task': (id: string) => boolean;
  'toggle-task': (id: string) => Task;
}

// Window ê°ì²´ì— electronAPI íƒ€ì… ì •ì˜
declare global {
  interface Window {
    electronAPI: {
      getTasks: () => Promise<Task[]>;
      addTask: (task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Task>;
      updateTask: (task: Task) => Promise<Task>;
      deleteTask: (id: string) => Promise<boolean>;
      toggleTask: (id: string) => Promise<Task>;
      
      // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
      onTasksUpdated: (callback: (tasks: Task[]) => void) => void;
      removeAllListeners: (channel: string) => void;
    };
  }
}
```

### Step 3: Main Process êµ¬í˜„

```typescript
// src/main/main.ts
import { app, BrowserWindow, ipcMain, Menu, Tray } from 'electron';
import * as path from 'path';
import * as fs from 'fs';
import { Task } from '@shared/types';

class TaskManagerApp {
  private mainWindow: BrowserWindow | null = null;
  private tray: Tray | null = null;
  private tasks: Task[] = [];
  private dataFile: string;

  constructor() {
    this.dataFile = path.join(app.getPath('userData'), 'tasks.json');
    this.loadTasks();
  }

  async initialize(): Promise<void> {
    await app.whenReady();
    
    this.createMainWindow();
    this.setupIpcHandlers();
    this.setupTray();
    this.setupMenu();
  }

  private createMainWindow(): void {
    this.mainWindow = new BrowserWindow({
      width: 800,
      height: 600,
      minWidth: 600,
      minHeight: 400,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, 'preload.js')
      },
      icon: this.getIcon(),
      title: 'Simple Task Manager'
    });

    // ê°œë°œ/í”„ë¡œë•ì…˜ í™˜ê²½ ë¶„ê¸°
    if (process.env.NODE_ENV === 'development') {
      this.mainWindow.loadURL('http://localhost:3000');
      this.mainWindow.webContents.openDevTools();
    } else {
      this.mainWindow.loadFile(path.join(__dirname, 'index.html'));
    }

    // ìœˆë„ìš° ì´ë²¤íŠ¸ í•¸ë“¤ë§
    this.mainWindow.on('close', (event) => {
      if (process.platform !== 'darwin') {
        event.preventDefault();
        this.mainWindow?.hide();
      }
    });

    this.mainWindow.on('closed', () => {
      this.mainWindow = null;
    });
  }

  private setupIpcHandlers(): void {
    ipcMain.handle('get-tasks', () => {
      return this.tasks;
    });

    ipcMain.handle('add-task', (_, taskData: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>) => {
      const task: Task = {
        id: this.generateId(),
        ...taskData,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      this.tasks.push(task);
      this.saveTasks();
      this.broadcastTasksUpdate();
      
      return task;
    });

    ipcMain.handle('update-task', (_, task: Task) => {
      const index = this.tasks.findIndex(t => t.id === task.id);
      if (index !== -1) {
        this.tasks[index] = { ...task, updatedAt: new Date().toISOString() };
        this.saveTasks();
        this.broadcastTasksUpdate();
        return this.tasks[index];
      }
      throw new Error('Task not found');
    });

    ipcMain.handle('delete-task', (_, id: string) => {
      const index = this.tasks.findIndex(t => t.id === id);
      if (index !== -1) {
        this.tasks.splice(index, 1);
        this.saveTasks();
        this.broadcastTasksUpdate();
        return true;
      }
      return false;
    });

    ipcMain.handle('toggle-task', (_, id: string) => {
      const task = this.tasks.find(t => t.id === id);
      if (task) {
        task.completed = !task.completed;
        task.updatedAt = new Date().toISOString();
        this.saveTasks();
        this.broadcastTasksUpdate();
        return task;
      }
      throw new Error('Task not found');
    });
  }

  private setupTray(): void {
    this.tray = new Tray(this.getIcon());
    
    const contextMenu = Menu.buildFromTemplate([
      {
        label: 'Show Tasks',
        click: () => this.showMainWindow()
      },
      {
        label: 'Add Task',
        click: () => {
          this.showMainWindow();
          // ìƒˆ ì‘ì—… ì¶”ê°€ í¼ìœ¼ë¡œ í¬ì»¤ìŠ¤
        }
      },
      { type: 'separator' },
      {
        label: `Tasks: ${this.tasks.length} (${this.tasks.filter(t => !t.completed).length} pending)`,
        enabled: false
      },
      { type: 'separator' },
      {
        label: 'Quit',
        click: () => app.quit()
      }
    ]);

    this.tray.setContextMenu(contextMenu);
    this.tray.setToolTip('Simple Task Manager');

    this.tray.on('click', () => {
      this.showMainWindow();
    });
  }

  private setupMenu(): void {
    const template: Electron.MenuItemConstructorOptions[] = [
      {
        label: 'File',
        submenu: [
          {
            label: 'New Task',
            accelerator: 'CmdOrCtrl+N',
            click: () => {
              this.mainWindow?.webContents.send('new-task-shortcut');
            }
          },
          { type: 'separator' },
          {
            label: 'Quit',
            accelerator: process.platform === 'darwin' ? 'Cmd+Q' : 'Ctrl+Q',
            click: () => app.quit()
          }
        ]
      },
      {
        label: 'Edit',
        submenu: [
          { role: 'undo' },
          { role: 'redo' },
          { type: 'separator' },
          { role: 'cut' },
          { role: 'copy' },
          { role: 'paste' }
        ]
      },
      {
        label: 'View',
        submenu: [
          { role: 'reload' },
          { role: 'forceReload' },
          { role: 'toggleDevTools' },
          { type: 'separator' },
          { role: 'resetZoom' },
          { role: 'zoomIn' },
          { role: 'zoomOut' },
          { type: 'separator' },
          { role: 'togglefullscreen' }
        ]
      }
    ];

    const menu = Menu.buildFromTemplate(template);
    Menu.setApplicationMenu(menu);
  }

  // ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  private loadTasks(): void {
    try {
      if (fs.existsSync(this.dataFile)) {
        const data = fs.readFileSync(this.dataFile, 'utf8');
        this.tasks = JSON.parse(data);
      }
    } catch (error) {
      console.error('Failed to load tasks:', error);
      this.tasks = [];
    }
  }

  private saveTasks(): void {
    try {
      fs.writeFileSync(this.dataFile, JSON.stringify(this.tasks, null, 2));
    } catch (error) {
      console.error('Failed to save tasks:', error);
    }
  }

  private broadcastTasksUpdate(): void {
    if (this.mainWindow) {
      this.mainWindow.webContents.send('tasks-updated', this.tasks);
    }
    this.updateTray();
  }

  private updateTray(): void {
    if (this.tray) {
      const pendingCount = this.tasks.filter(t => !t.completed).length;
      this.tray.setToolTip(`Simple Task Manager - ${pendingCount} pending tasks`);
      this.setupTray(); // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì—…ë°ì´íŠ¸
    }
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  private getIcon(): string {
    // ê°„ë‹¨í•œ ì•„ì´ì½˜ ê²½ë¡œ (ì‹¤ì œë¡œëŠ” assets í´ë”ì— ì•„ì´ì½˜ íŒŒì¼ í•„ìš”)
    return path.join(__dirname, '../assets/icon.png');
  }

  private showMainWindow(): void {
    if (this.mainWindow) {
      if (this.mainWindow.isMinimized()) {
        this.mainWindow.restore();
      }
      this.mainWindow.show();
      this.mainWindow.focus();
    }
  }

  public quit(): void {
    this.saveTasks();
    app.quit();
  }
}

// ì•± ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° ì´ë²¤íŠ¸ í•¸ë“¤ë§
const taskManagerApp = new TaskManagerApp();

app.on('ready', () => {
  taskManagerApp.initialize();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    taskManagerApp.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    taskManagerApp.initialize();
  }
});

app.on('before-quit', () => {
  taskManagerApp.quit();
});
```### Step 4: Preload Script êµ¬í˜„

```typescript
// src/main/preload.ts
import { contextBridge, ipcRenderer } from 'electron';
import type { Task } from '@shared/types';

// íƒ€ì… ì•ˆì „í•œ API ê°ì²´ ì •ì˜
const electronAPI = {
  // Task CRUD ì‘ì—…
  getTasks: (): Promise<Task[]> => ipcRenderer.invoke('get-tasks'),
  
  addTask: (task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<Task> => {
    // ì…ë ¥ ê²€ì¦
    if (!task.title || task.title.trim().length === 0) {
      return Promise.reject(new Error('Task title is required'));
    }
    if (task.title.length > 100) {
      return Promise.reject(new Error('Task title is too long'));
    }
    
    const sanitizedTask = {
      title: task.title.trim(),
      description: task.description?.trim() || '',
      completed: Boolean(task.completed)
    };
    
    return ipcRenderer.invoke('add-task', sanitizedTask);
  },
  
  updateTask: (task: Task): Promise<Task> => {
    // ì…ë ¥ ê²€ì¦
    if (!task.id) {
      return Promise.reject(new Error('Task ID is required'));
    }
    if (!task.title || task.title.trim().length === 0) {
      return Promise.reject(new Error('Task title is required'));
    }
    
    const sanitizedTask = {
      ...task,
      title: task.title.trim(),
      description: task.description?.trim() || ''
    };
    
    return ipcRenderer.invoke('update-task', sanitizedTask);
  },
  
  deleteTask: (id: string): Promise<boolean> => {
    if (!id || id.trim().length === 0) {
      return Promise.reject(new Error('Task ID is required'));
    }
    return ipcRenderer.invoke('delete-task', id.trim());
  },
  
  toggleTask: (id: string): Promise<Task> => {
    if (!id || id.trim().length === 0) {
      return Promise.reject(new Error('Task ID is required'));
    }
    return ipcRenderer.invoke('toggle-task', id.trim());
  },

  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
  onTasksUpdated: (callback: (tasks: Task[]) => void): void => {
    ipcRenderer.on('tasks-updated', (_, tasks) => callback(tasks));
  },

  onNewTaskShortcut: (callback: () => void): void => {
    ipcRenderer.on('new-task-shortcut', callback);
  },

  // ì´ë²¤íŠ¸ ì •ë¦¬
  removeAllListeners: (channel: string): void => {
    ipcRenderer.removeAllListeners(channel);
  },

  // ìœ í‹¸ë¦¬í‹°
  getAppVersion: (): string => {
    try {
      return require('../../package.json').version;
    } catch {
      return '1.0.0';
    }
  },

  getPlatform: (): string => process.platform,
  
  isDev: (): boolean => process.env.NODE_ENV === 'development'
};

// Context Bridgeë¥¼ í†µí•´ ì•ˆì „í•˜ê²Œ API ë…¸ì¶œ
contextBridge.exposeInMainWorld('electronAPI', electronAPI);

// TypeScript ì§€ì›ì„ ìœ„í•œ ì „ì—­ íƒ€ì… ì„ ì–¸
declare global {
  interface Window {
    electronAPI: typeof electronAPI;
  }
}
```

### Step 5: React Frontend êµ¬í˜„

#### 5.1 ë©”ì¸ App ì»´í¬ë„ŒíŠ¸
```tsx
// src/renderer/App.tsx
import React, { useState, useEffect } from 'react';
import { Task } from '@shared/types';
import TaskForm from './components/TaskForm';
import TaskList from './components/TaskList';
import Stats from './components/Stats';
import './styles.css';

const App: React.FC = () => {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showForm, setShowForm] = useState(false);
  const [editingTask, setEditingTask] = useState<Task | null>(null);

  // ì´ˆê¸° ë°ì´í„° ë¡œë“œ
  useEffect(() => {
    loadTasks();
    setupEventListeners();
    
    return () => {
      // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
      window.electronAPI.removeAllListeners('tasks-updated');
      window.electronAPI.removeAllListeners('new-task-shortcut');
    };
  }, []);

  const loadTasks = async (): Promise<void> => {
    try {
      setLoading(true);
      const tasksData = await window.electronAPI.getTasks();
      setTasks(tasksData);
      setError(null);
    } catch (err) {
      setError('Failed to load tasks');
      console.error('Load tasks error:', err);
    } finally {
      setLoading(false);
    }
  };

  const setupEventListeners = (): void => {
    // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ìˆ˜ì‹ 
    window.electronAPI.onTasksUpdated((updatedTasks: Task[]) => {
      setTasks(updatedTasks);
    });

    // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì²˜ë¦¬
    window.electronAPI.onNewTaskShortcut(() => {
      setShowForm(true);
      setEditingTask(null);
    });
  };

  const handleAddTask = async (taskData: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<void> => {
    try {
      await window.electronAPI.addTask(taskData);
      setShowForm(false);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to add task');
    }
  };

  const handleUpdateTask = async (task: Task): Promise<void> => {
    try {
      await window.electronAPI.updateTask(task);
      setEditingTask(null);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update task');
    }
  };

  const handleDeleteTask = async (id: string): Promise<void> => {
    if (!confirm('Are you sure you want to delete this task?')) {
      return;
    }
    
    try {
      await window.electronAPI.deleteTask(id);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete task');
    }
  };

  const handleToggleTask = async (id: string): Promise<void> => {
    try {
      await window.electronAPI.toggleTask(id);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to toggle task');
    }
  };

  const handleEditTask = (task: Task): void => {
    setEditingTask(task);
    setShowForm(true);
  };

  const handleCancelEdit = (): void => {
    setShowForm(false);
    setEditingTask(null);
  };

  if (loading) {
    return (
      <div className="app loading">
        <div className="spinner"></div>
        <p>Loading tasks...</p>
      </div>
    );
  }

  return (
    <div className="app">
      <header className="app-header">
        <h1>Simple Task Manager</h1>
        <button 
          className="btn btn-primary"
          onClick={() => setShowForm(!showForm)}
        >
          {showForm ? 'Cancel' : 'Add Task'}
        </button>
      </header>

      {error && (
        <div className="error-banner">
          {error}
          <button onClick={() => setError(null)}>Ã—</button>
        </div>
      )}

      <main className="app-main">
        <Stats tasks={tasks} />
        
        {showForm && (
          <TaskForm
            task={editingTask}
            onSubmit={editingTask ? handleUpdateTask : handleAddTask}
            onCancel={handleCancelEdit}
          />
        )}

        <TaskList
          tasks={tasks}
          onToggle={handleToggleTask}
          onEdit={handleEditTask}
          onDelete={handleDeleteTask}
        />
      </main>

      <footer className="app-footer">
        <p>
          Simple Task Manager v{window.electronAPI.getAppVersion()} 
          â€¢ Platform: {window.electronAPI.getPlatform()}
          {window.electronAPI.isDev() && ' â€¢ Development Mode'}
        </p>
      </footer>
    </div>
  );
};

export default App;
```

#### 5.2 TaskForm ì»´í¬ë„ŒíŠ¸
```tsx
// src/renderer/components/TaskForm.tsx
import React, { useState, useEffect } from 'react';
import { Task } from '@shared/types';

interface TaskFormProps {
  task?: Task | null;
  onSubmit: (taskData: Omit<Task, 'id' | 'createdAt' | 'updatedAt'> | Task) => void;
  onCancel: () => void;
}

const TaskForm: React.FC<TaskFormProps> = ({ task, onSubmit, onCancel }) => {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [completed, setCompleted] = useState(false);
  const [errors, setErrors] = useState<{ title?: string; description?: string }>({});

  useEffect(() => {
    if (task) {
      setTitle(task.title);
      setDescription(task.description);
      setCompleted(task.completed);
    } else {
      setTitle('');
      setDescription('');
      setCompleted(false);
    }
    setErrors({});
  }, [task]);

  const validateForm = (): boolean => {
    const newErrors: { title?: string; description?: string } = {};

    if (!title.trim()) {
      newErrors.title = 'Title is required';
    } else if (title.length > 100) {
      newErrors.title = 'Title must be less than 100 characters';
    }

    if (description.length > 500) {
      newErrors.description = 'Description must be less than 500 characters';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e: React.FormEvent): void => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    const taskData = {
      title: title.trim(),
      description: description.trim(),
      completed
    };

    if (task) {
      onSubmit({ ...task, ...taskData });
    } else {
      onSubmit(taskData);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent): void => {
    if (e.key === 'Escape') {
      onCancel();
    }
  };

  return (
    <form className="task-form" onSubmit={handleSubmit} onKeyDown={handleKeyDown}>
      <h3>{task ? 'Edit Task' : 'Add New Task'}</h3>
      
      <div className="form-group">
        <label htmlFor="title">Title *</label>
        <input
          id="title"
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="Enter task title..."
          className={errors.title ? 'error' : ''}
          autoFocus
          maxLength={100}
        />
        {errors.title && <span className="error-text">{errors.title}</span>}
      </div>

      <div className="form-group">
        <label htmlFor="description">Description</label>
        <textarea
          id="description"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          placeholder="Enter task description (optional)..."
          className={errors.description ? 'error' : ''}
          rows={3}
          maxLength={500}
        />
        {errors.description && <span className="error-text">{errors.description}</span>}
        <small className="char-count">{description.length}/500</small>
      </div>

      {task && (
        <div className="form-group">
          <label>
            <input
              type="checkbox"
              checked={completed}
              onChange={(e) => setCompleted(e.target.checked)}
            />
            Mark as completed
          </label>
        </div>
      )}

      <div className="form-actions">
        <button type="submit" className="btn btn-primary">
          {task ? 'Update Task' : 'Add Task'}
        </button>
        <button type="button" className="btn btn-secondary" onClick={onCancel}>
          Cancel
        </button>
      </div>
    </form>
  );
};

export default TaskForm;
```

### Step 6: Webpack ì„¤ì •

#### 6.1 Main Process ë¹Œë“œ ì„¤ì •
```javascript
// webpack.main.config.js
const path = require('path');

module.exports = {
  entry: {
    main: './src/main/main.ts',
    preload: './src/main/preload.ts'
  },
  target: 'electron-main',
  mode: process.env.NODE_ENV || 'development',
  devtool: process.env.NODE_ENV === 'development' ? 'source-map' : false,
  module: {
    rules: [
      {
        test: /\.ts$/,
        include: /src/,
        use: [{ loader: 'ts-loader' }]
      }
    ]
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js'
  },
  resolve: {
    extensions: ['.ts', '.js'],
    alias: {
      '@': path.resolve(__dirname, 'src'),
      '@shared': path.resolve(__dirname, 'src/shared')
    }
  },
  node: {
    __dirname: false,
    __filename: false
  }
};
```

#### 6.2 Renderer Process ë¹Œë“œ ì„¤ì •
```javascript
// webpack.renderer.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
  entry: './src/renderer/index.tsx',
  target: 'electron-renderer',
  mode: process.env.NODE_ENV || 'development',
  devtool: process.env.NODE_ENV === 'development' ? 'source-map' : false,
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        include: /src/,
        use: [{ loader: 'ts-loader' }]
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  devServer: {
    port: 3000,
    hot: true,
    historyApiFallback: true
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/renderer/index.html'
    })
  ],
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
    alias: {
      '@': path.resolve(__dirname, 'src'),
      '@shared': path.resolve(__dirname, 'src/shared')
    }
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'renderer.js',
    publicPath: './'
  }
};
```

## ê³¼ì œ ë° í™•ì¥ ê¸°ëŠ¥

### ê³¼ì œ 1: ê¸°ë³¸ ê¸°ëŠ¥ ì™„ì„±
1. **ë‚¨ì€ ì»´í¬ë„ŒíŠ¸ êµ¬í˜„** (TaskList, Stats, ìŠ¤íƒ€ì¼ë§)
2. **ì—ëŸ¬ ì²˜ë¦¬ ê°•í™”** (ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬, íŒŒì¼ ì‹œìŠ¤í…œ ì—ëŸ¬)
3. **í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì¶”ê°€** (Ctrl+Enterë¡œ ì‘ì—… ì¶”ê°€, Deleteë¡œ ì‚­ì œ)

### ê³¼ì œ 2: ê³ ê¸‰ ê¸°ëŠ¥ ì¶”ê°€
1. **ê²€ìƒ‰ ë° í•„í„°ë§** (ì™„ë£Œ/ë¯¸ì™„ë£Œ, í‚¤ì›Œë“œ ê²€ìƒ‰)
2. **ì‘ì—… ë¶„ë¥˜** (ì¹´í…Œê³ ë¦¬ ë˜ëŠ” íƒœê·¸ ì‹œìŠ¤í…œ)
3. **ë§ˆê°ì¼ ê´€ë¦¬** (due date, ì•Œë¦¼)
4. **ë°ì´í„° ë°±ì—…/ë³µì›** (JSON export/import)

### ê³¼ì œ 3: ì„±ëŠ¥ ë° UX ê°œì„ 
1. **ê°€ìƒí™”** (ë§ì€ ì‘ì—… í•­ëª© ì²˜ë¦¬)
2. **ë“œë˜ê·¸ ì•¤ ë“œë¡­** (ì‘ì—… ìˆœì„œ ë³€ê²½)
3. **í…Œë§ˆ ì‹œìŠ¤í…œ** (ë‹¤í¬/ë¼ì´íŠ¸ ëª¨ë“œ)
4. **ìƒíƒœ ì• ë‹ˆë©”ì´ì…˜** (ì‘ì—… ì™„ë£Œ ì‹œ ì• ë‹ˆë©”ì´ì…˜)

### ë„ì „ ê³¼ì œ: ì‹¤ë¬´ ìˆ˜ì¤€ ê¸°ëŠ¥
1. **ìë™ ì €ì¥** (ì‹¤ì‹œê°„ ì €ì¥, ì¶©ëŒ í•´ê²°)
2. **ë‹¤ì¤‘ ì°½ ì§€ì›** (ì—¬ëŸ¬ íƒœìŠ¤í¬ ë¦¬ìŠ¤íŠ¸ ì°½)
3. **í´ë¼ìš°ë“œ ë™ê¸°í™”** (Google Drive, Dropbox ì—°ë™)
4. **í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ** (í™•ì¥ ê¸°ëŠ¥ ì•„í‚¤í…ì²˜)

## í•™ìŠµ ì •ë¦¬ ë° íšŒê³ 

### ğŸ¯ 1ì£¼ì°¨ í•™ìŠµ ì„±ê³¼ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] **Electron ì•„í‚¤í…ì²˜ ì´í•´** - Main/Renderer/Preload ì—­í•  êµ¬ë¶„
- [ ] **IPC í†µì‹  êµ¬í˜„** - íƒ€ì… ì•ˆì „í•œ í†µì‹  ì±„ë„ êµ¬ì¶•  
- [ ] **ë³´ì•ˆ ëª¨ë¸ ì ìš©** - Context Isolationê³¼ ì…ë ¥ ê²€ì¦
- [ ] **ë¹Œë“œ ì‹œìŠ¤í…œ êµ¬ì„±** - ê°œë°œ/í”„ë¡œë•ì…˜ í™˜ê²½ ë¶„ë¦¬
- [ ] **ì‹¤ë¬´ íŒ¨í„´ ì ìš©** - ì—ëŸ¬ ì²˜ë¦¬, ì´ë²¤íŠ¸ ê´€ë¦¬, ì½”ë“œ êµ¬ì¡°

### ğŸ’¡ í•µì‹¬ í•™ìŠµ í¬ì¸íŠ¸

1. **ì•„í‚¤í…ì²˜ ì´í•´ì˜ ì¤‘ìš”ì„±**
   - ê° í”„ë¡œì„¸ìŠ¤ì˜ ì—­í• ê³¼ ì œì•½ì‚¬í•­ ì´í•´
   - IPCë¥¼ í†µí•œ ì•ˆì „í•œ í†µì‹  ì„¤ê³„

2. **ë³´ì•ˆ ìš°ì„  ê°œë°œ**
   - Context Bridge íŒ¨í„´ì˜ í™œìš©
   - ì…ë ¥ ê²€ì¦ê³¼ ë°ì´í„° ì •í™”

3. **ê°œë°œì ê²½í—˜**
   - HMRì„ í†µí•œ ë¹ ë¥¸ ê°œë°œ ì‚¬ì´í´
   - TypeScriptë¥¼ í†µí•œ íƒ€ì… ì•ˆì „ì„±

4. **ì‹¤ë¬´ ê°œë°œ íŒ¨í„´**
   - ì—ëŸ¬ ì²˜ë¦¬ì™€ ì‚¬ìš©ì í”¼ë“œë°±
   - ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜

### ğŸ“ˆ ë‹¤ìŒ ë‹¨ê³„ í•™ìŠµ ë°©í–¥

**2ì£¼ì°¨ ì¤€ë¹„ì‚¬í•­:**
- ì„œë¹„ìŠ¤ ë ˆì´ì–´ ì•„í‚¤í…ì²˜ ì‹¬í™” í•™ìŠµ
- ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ì™€ ORM íŒ¨í„´
- ì™¸ë¶€ API í†µí•©ê³¼ ì—ëŸ¬ ì²˜ë¦¬
- ì‹œìŠ¤í…œ í†µí•© (íŠ¸ë ˆì´, ì•Œë¦¼, ìë™ ì‹œì‘)

---
*ğŸ‰ **1ì£¼ì°¨ ì™„ì£¼ ì¶•í•˜í•©ë‹ˆë‹¤!** ì´ì œ Electronì˜ ê¸°ì´ˆë¥¼ ì™„ì „íˆ ì´í•´í–ˆìŠµë‹ˆë‹¤. 2ì£¼ì°¨ì—ì„œëŠ” ë”ìš± ì‹¤ë¬´ì ì´ê³  ê³ ê¸‰ìŠ¤ëŸ¬ìš´ ê¸°ëŠ¥ë“¤ì„ í•™ìŠµí•˜ê²Œ ë©ë‹ˆë‹¤.*